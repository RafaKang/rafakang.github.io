[{"content":"A 题目链接\n直接按题意模拟即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Main() { int N, C; std::cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; C; std::vector\u0026lt;int\u0026gt; T(N + 1); for (int i = 1; i \u0026lt;= N; ++i) std::cin \u0026gt;\u0026gt; T[i]; int last = -1e9, ans = 0; for (int i = 1; i \u0026lt;= N; ++i) if (T[i] - last \u0026gt;= C) ++ans, last = T[i]; std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } B 题目链接\n以左手为例。假设当前位置是$l$，要去的位置是$t$。\n实际上只有两种走过去的方式——顺时针和逆时针。\n如果顺时针走先碰到右手的位置$r$，那么只能逆时针走。等价于顺时针走$l$到$r$的距离小于$l$到$t$的距离。\n于是我们写一个函数求从$a$走到$b$，按逆时针和顺时针的距离即可。\n以顺时针为例，距离的求法是$b-a(b\u0026gt;a);n+b-a(b\u0026lt;a)$。或者统一一下，直接写$(n+b-a)\\bmod n$。\n逆时针走就是用$n$减去顺时针走的距离。\n那么这道题就解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int dist(int n, int a, int b, int d) { if (d == 1) return (n + (b - a)) % n; else return (n - (n + (b - a)) % n) % n; }; int Main() { int n, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; int l = 1, r = 2; int ans = 0; for (int i = 1; i \u0026lt;= q; ++i) { std::string h; int t; std::cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; t; if (h == \u0026#34;L\u0026#34;) { if (dist(n, l, t, 1) \u0026gt;= dist(n, l, r, 1)) ans += dist(n, l, t, -1); else ans += dist(n, l, t, 1); l = t; } else { if (dist(n, r, t, 1) \u0026gt;= dist(n, r, l, 1)) ans += dist(n, r, t, -1); else ans += dist(n, r, t, 1); r = t; } // std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } C 题目链接\n如果有N个箱子和N个玩具，想每个玩具都放进去的话，那么一定是排序之后，$a[i]\\leq b[i]$。\n考虑现在少一个箱子，那么可以在出现$a[i]\u0026gt;b[i]$的时候，买一个$a[i]$大小的箱子就行。\n这里可以使用双指针，一个指针$i$指向$a$数组，第二个指针$j$指向$b$数组。如果出现$j\u0026lt;i$且装不下的情况，就无解。因为这时已经买了一个箱子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int Main() { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; a(n + 1), b(n); for (int i = 1; i \u0026lt;= n; ++i) std::cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n - 1; ++i) std::cin \u0026gt;\u0026gt; b[i]; std::sort(a.begin() + 1, a.end(), std::greater\u0026lt;int\u0026gt;{}); std::sort(b.begin() + 1, b.end(), std::greater\u0026lt;int\u0026gt;{}); b.push_back(0); int ans = 0; for (int i = 1, j = 1; i \u0026lt;= n; ++i) { if (a[i] \u0026lt;= b[j]) { j++; continue; } else if (std::abs(j - i) == 1) return printf(\u0026#34;-1\\n\u0026#34;), 0; else ans = a[i]; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } D 题目链接\n找到通向$1$的最小环，等价于有向图上找从$1$开始到$1$的前继的点的最短路。由于图没有边权，因此使用bfs即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int Main() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector adj(n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt;= m; ++i) { int u, v; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); } std::queue\u0026lt;int\u0026gt; q; q.push(1); std::vector\u0026lt;int\u0026gt; dist(n + 1, 1e9); dist[1] = 0; while (q.size()) { int u = q.front(); q.pop(); for (int v : adj[u]) { if (v == 1) return printf(\u0026#34;%d\\n\u0026#34;, dist[u] + 1), 0; if (dist[v] \u0026gt; dist[u] + 1) dist[v] = dist[u] + 1, q.push(v); } } printf(\u0026#34;-1\\n\u0026#34;); return 0; } E 题目链接\n这种两个元素组合起来求一个最小值或者最大值的题，一般的解决方法是枚举其中一个元素，然后以枚举到的值为限制，求另一个值的最小值。\n以这道题为例，可以枚举$max(A[i])$。那么我们发现，能加入到子序列中的都是比$A[i]$小的值。\n相当于把两个数组都按$A[i]$排序之后，取$A[i]$为最大值，然后在$A[1]\u0026hellip;A[i-1]$里找到$K-1$个数使得$B$数组的和最小。\n显然找到找到最小的$K-1$个$B$数组里的数就行。那么维护一个大小为$K-1$的set或者堆即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 int Main() { int N, K; std::cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; std::vector\u0026lt;int\u0026gt; A(N + 1), B(N + 1); for (int i = 1; i \u0026lt;= N; i++) { std::cin \u0026gt;\u0026gt; A[i]; } for (int i = 1; i \u0026lt;= N; i++) { std::cin \u0026gt;\u0026gt; B[i]; } ll ans = 1e18; std::vector\u0026lt;int\u0026gt; ord(N + 1); for (int i = 1; i \u0026lt;= N; ++i) ord[i] = i; std::sort(ord.begin() + 1, ord.end(), [\u0026amp;](int i, int j) { return A[i] \u0026lt; A[j]; }); std::priority_queue\u0026lt;int\u0026gt; pq; ll sum = 0; for (int p = 1; p \u0026lt;= N; ++p) { int i = ord[p]; sum += B[i]; pq.push(B[i]); while (pq.size() \u0026gt; K) { sum -= pq.top(); pq.pop(); } if (pq.size() == K) ans = std::min(ans, sum * A[i]); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } F 题目链接\n可以考虑一个dp。\n$dp[i][j]$表示前$i$个查询之后，另一只手在$j$位置的最小操作数。然而这里“另一只手”的描述稍微有点不利于转移。\n注意到每次操作之后都有某一只手的位置是固定的，现在未知的就是另一只手的位置，我们的枚举也是另一只手。为了方便明确状态和转移，这里不妨以两只手的某种关系来做状态的第二维。\n例如：两只手位置的和、两只手位置的差、两只手位置的乘积等等。\n这里选择两只手位置的和$s$来做状态的第二维。那么只需要根据上一个操作即可解出目前两只手的位置。注意规避两只手位置相同，或者小于等于$0$的情况。\n其实更好的状态可以选择枚举两只手位置的异或值。这样只要我们不从$0$开始枚举，那么能规避两只手位置是负数以及相同的情况，可以少写一些判断。\n接下来考虑$dp[i][s]$。前i个查询之后，目前两只手位置和为$s$的最小操作数。\n我们在思考转移的时候，感觉前一个状态不太好找。那么不妨考虑顺推。用$dp[i][s]$去推$dp[i+1][s\u0026rsquo;]$。\n现在我们知道$i$查询之后的左右手的值$l, r$。\n以及$i+1$查询，某一只手的目的地$t$。假设是左手。\n根据B题的结论，我们依旧是两种决策——从顺时针走和逆时针走。\n如果从顺时针走先碰到了右手，那么右手的最终位置是$(t+1) \\bmod n$。\n从逆时针走先碰到右手，右手的最终位置是$(t-1) \\bmod n$。\n用B题的距离函数判断一下并计算转移即可。\n这样题目就解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 int Main() { int n, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; op(q + 1); for (int i = 1; i \u0026lt;= q; ++i) { std::string h; std::cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; op[i][1]; op[i][0] = (h == \u0026#34;R\u0026#34;); } std::vector dp(q + 1, std::vector\u0026lt;int\u0026gt;(n * 2 + 1, 1e9)); dp[0][3] = 0; op[0] = {0, 1}; auto dist = [\u0026amp;](int a, int b, int d) { if (d == 1) return (n + (b - a)) % n; else return (n - (n + (b - a)) % n) % n; }; for (int i = 0; i \u0026lt; q; ++i) { for (int s = 2; s \u0026lt;= n + n; ++s) { if (dp[i][s] \u0026gt; 2 * q * n) continue; int l = (op[i][0] == 0) ? op[i][1] : (s - op[i][1]); int r = (op[i][0] == 1) ? op[i][1] : (s - op[i][1]); if (l \u0026lt;= 0 || r \u0026lt;= 0 || l == r) continue; if (op[i + 1][0] == 1) std::swap(l, r); // printf(\u0026#34;dp[%d][%d][%d] = %d\\n\u0026#34;, i, l, r, dp[i][s]); int L = op[i + 1][1]; if (dist(l, L, -1) \u0026gt;= dist(l, r, -1)) { int R = (L - 1) % n; if (R == 0) R = n; dp[i + 1][L + R] = std::min(dp[i + 1][L + R], dist(l, L, -1) + dist(r, R, -1) + dp[i][s]); } if (dist(l, L, -1) \u0026lt; dist(l, r, -1)) { dp[i + 1][L + r] = std::min(dp[i + 1][L + r], dist(l, L, -1) + dp[i][s]); } if (dist(l, L, 1) \u0026gt;= dist(l, r, 1)) { int R = (L + 1) % n; if (R == 0) R = n; dp[i + 1][L + R] = std::min(dp[i + 1][L + R], dist(l, L, 1) + dist(r, R, 1) + dp[i][s]); } if (dist(l, L, 1) \u0026lt; dist(l, r, 1)) dp[i + 1][L + r] = std::min(dp[i + 1][L + r], dist(l, L, 1) + dp[i][s]); } } int ans = *std::min_element(dp[q].begin(), dp[q].end()); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } G 题目链接\n一道数学期望的题目。\n假设有一个探测排列$q$。我们来分析一下这个$q$有什么性质。\n$q[i]$在第$i$次被探测到，那么相当于$q[i]$的父亲在$i$之前被探测到了。\n也就是说，$q$中节点的顺序，应该保证$q[i]$的父亲在$q[i]$之前出现。\n然后考虑这个排列$q$的操作期望。设$sum$是$a$的总和。\n如果财宝在$q[i]$位置，那么有$\\frac{a[q[i]]}{sum}$的概率在$q[i]$停止探测。\n于是根据期望的公式，一个排列$q$的期望操作次数就是 $$E(q)=\\sum_{i=1}^n \\frac{i*a[q[i]]}{sum}$$注意到$sum$是一个定值。那么最小期望操作次数的排列$q$，满足$\\sum_{i=1}^n i*a[q[i]]$是最小的。\n整理一下，最佳的排列$q$，需要满足两个条件：\n1.$q$中节点的顺序，应该保证$q[i]$的父亲在$q[i]$之前出现\n2.$\\sum_{i=1}^n i*a[q[i]]$是最小的\n这个问题叫做按树上先序的贪心。\n原题是2018年湖南省队的题目排列。\n贪心的idea可能比较反直觉。\n假设没有树上的父亲要在前面这个条件，根据排序不等式，显然是把$a[i]$按降序排序能得到最小值。\n那么考虑当前最大的$a[i]$。\n如果$a[i]$的父亲是$0$，那么可以直接搜点$i$。\n如果$a[i]$有其它的父亲，那么一定是搜完了父亲之后，直接来搜$i$。\n第二句话等价于在最优排列中，$i$的父亲和$i$一定是挨着的。\n因此我们可以考虑把$i$和$i$的父亲合并起来，因为他们俩必定是挨在一起出现。\n于是若干操作之后，要比较的是多个合并后的节点。\n那么合并之后的节点需要怎么计算权重呢？\n根据题目限制的条件，假设两个合并之后的节点$x$和$y$，分别代表两个必须要挨在一起的序列。\n节点x的序列长度为$c_1$，序列权重和为$s_1$，这个序列的答案$(\\sum i*a[i])$是$ans_1$。节点y的序列长度为$c2$，序列权重和为$s2$，序列的答案是$ans_2$。\n如果$x$在$y$之前，相当于为答案提供的贡献是$ans_1+ans_2+c_1* s_2$。反之，为答案提供的贡献是$ans_2+ans_1+c_2*s_1$。\n如果$x$在$y$之前更好，把这两个式子做一个差，等价于$\\frac{s_1}{c_1}\u0026gt;\\frac{s_2}{c_2}$;相当于合并之后的节点，权重是平均值。\n用堆维护当前节点的权重大小，用并查集维护节点之间的合并关系，这道题就解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include \u0026lt;atcoder/modint\u0026gt; using modint = atcoder::modint998244353; struct DSU { public: DSU() : n(0) {} explicit DSU(int _n) : n(_n), parent_or_size(_n + 1, -1) {} int merge(int a, int b) { int x = leader(a), y = leader(b); if (x == y) return x; parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x; return x; } bool same(int a, int b) { return leader(a) == leader(b); } int leader(int a) { if (parent_or_size[a] \u0026lt; 0) return a; return parent_or_size[a] = leader(parent_or_size[a]); } int size(int a) { return -parent_or_size[leader(a)]; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; groups() { std::vector\u0026lt;int\u0026gt; leader_buf(n + 1), group_size(n + 1); for (int i = 1; i \u0026lt;= n; i++) { leader_buf[i] = leader(i); group_size[leader_buf[i]]++; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result(n); for (int i = 1; i \u0026lt;= n; i++) { result[i].reserve(group_size[i]); } for (int i = 1; i \u0026lt;= n; i++) { result[leader_buf[i]].push_back(i); } result.erase( std::remove_if(result.begin(), result.end(), [\u0026amp;](const std::vector\u0026lt;int\u0026gt; \u0026amp;v) { return v.empty(); }), result.end()); return result; } private: int n; // root node: -1 * component size // otherwise: parent std::vector\u0026lt;int\u0026gt; parent_or_size; }; int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(p[i]); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); p[0] = -1; struct comp { bool operator()(const std::array\u0026lt;int, 3\u0026gt; \u0026amp;lhs, const std::array\u0026lt;int, 3\u0026gt; \u0026amp;rhs) const { auto [_, v1, s1] = lhs; auto [__, v2, s2] = rhs; return 1ll * v1 * s2 \u0026lt; 1ll * v2 * s1; } }; DSU dsu(n); std::priority_queue\u0026lt;std::array\u0026lt;int, 3\u0026gt;, std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt;, comp\u0026gt; heap{}; for (int i = 1; i \u0026lt;= n; ++i) { heap.push({i, a[i], 1}); } modint ans = 0; int size = 0; while (heap.size()) { auto [i, v, cnt] = heap.top(); heap.pop(); int fa = p[i]; if (dsu.leader(i) != i || cnt != dsu.size(i)) continue; int u = dsu.leader(p[i]); ans += 1ll * dsu.size(u) * v; a[u] += v; dsu.merge(u, i); if (u != 0) heap.push({u, a[u], dsu.size(u)}); } ans /= modint(a[0]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2024-10-21T11:35:33+08:00","image":"https://rafakang.github.io/p/abc376%E9%A2%98%E8%A7%A3/background_hu211459687380468525.png","permalink":"https://rafakang.github.io/p/abc376%E9%A2%98%E8%A7%A3/","title":"ABC376题解"},{"content":"A 题目链接\n串$s$和$t$如果具有一段公共前缀，那么可以用1s的时间复制这段前缀。找到这个最长的公共前缀即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int Main() { std::string s, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n = s.length(), m = t.length(); int ans = n + m; for (int i = 0; i \u0026lt; std::min(n, m); ++i) { if (s[i] != t[i]) break; else ans = std::min(ans, (i + 1) + 1 + (n - i - 1) + (m - i - 1)); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } B 题目链接\n手推一下不难得到，对于$(0\\leq k\u0026lt;n)$，$c[n][k]=2^k$。直接输出答案即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int Main() { int t; read(t); std::vector\u0026lt;int\u0026gt; n(t + 1), k(t + 1); for (int i = 1; i \u0026lt;= t; ++i) { read(n[i]); } for (int i = 1; i \u0026lt;= t; ++i) { read(k[i]); } std::vector\u0026lt;modint\u0026gt; bi(100001); bi[0] = 1; for (int i = 1; i \u0026lt;= 100000; ++i) bi[i] = bi[i - 1] * 2; for (int i = 1; i \u0026lt;= t; ++i) { printf(\u0026#34;%d\\n\u0026#34;, bi[k[i]]); } return 0; } C 题目链接\n最优策略一定是从把价值为$x$的卡拿完之后再去拿$x+1$；重复这个过程直到下一种价值不存在或者已经拿到了$x+k-1$。\n于是排序之后用双指针维护一下即可。\n主要代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int Main() { int n, k; read(n, k); std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); std::sort(a.begin() + 1, a.end()); int ans = 0; for (int i = 1, j = 1; i \u0026lt;= n; ++i) { if (j \u0026lt; i) j = i; while (j \u0026lt; n \u0026amp;\u0026amp; a[j + 1] - a[j] \u0026lt;= 1 \u0026amp;\u0026amp; a[j + 1] \u0026lt; a[i] + k) ++j; ans = std::max(j - i + 1, ans); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } D 题目链接\n一共有$m$个技能点，每个技能点两种决策，提示我们用DP的方式解决问题。 设$dp[i][j]$表示前$i$个技能点，力量上加了$j$点能够通过的最多关卡。\n显然在第$i$位有两种决策，加到力量上和加到智力上，子问题分别对应$dp[i-1][j-1]$和$dp[i-1][j]$。转移的时候检测一下子问题的状态能够在技能点$i-1$到技能点$i$中间通过多少关卡即可，即中间这些关卡在值域上的一段区间和，用前缀和处理一下就行了。\n主要代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 int Main() { int n, m; read(n, m); std::vector\u0026lt;int\u0026gt; r(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(r[i]), r[i] += m; std::vector\u0026lt;int\u0026gt; s(1); for (int i = 1; i \u0026lt;= n; ++i) if (r[i] == m) s.push_back(i); s.push_back(n + 1); std::vector dp(m + 2, std::vector\u0026lt;int\u0026gt;(m + 2, -1e9)); dp[0][0] = 0; std::vector\u0026lt;int\u0026gt; b(m + m + 4), sum(m + m + 4); for (int i = 1, p = 1; i \u0026lt;= m + 1; ++i) { for (int j = 0; j \u0026lt;= m + m + 2; ++j) b[j] = 0; while (p \u0026lt; s[i]) { b[r[p]]++; p++; } p++; sum[0] = b[0]; for (int j = 1; j \u0026lt;= m + m + 2; ++j) sum[j] = sum[j - 1] + b[j]; auto query = [\u0026amp;](int l, int r) { if (l == 0) return sum[r]; return sum[r] - sum[l - 1]; }; for (int j = 0; j \u0026lt;= i; ++j) { if (i - 1 \u0026gt;= j) dp[i][j] = std::max(dp[i][j], dp[i - 1][j] + query(-(i - 1 - j) + m, j + m)); if (j \u0026gt;= 1) dp[i][j] = std::max(dp[i][j], dp[i - 1][j - 1] + query(j - i + m, j - 1 + m)); // printf(\u0026#34;dp[%d][%d] = %d\\n\u0026#34;, i, j, dp[i][j]); } } int ans = 0; for (int i = 0; i \u0026lt;= m + 1; ++i) ans = std::max(ans, dp[m + 1][i]); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } E 题目链接\n这种计数问题首先考虑计数对象的特征——即什么样的牌能让玩家1永远胜过玩家2。\n1牌很特殊，首先从1牌开始考虑。\n假设玩家2抽到了$k$张1牌，那么玩家1至少要有$k$张1牌，且玩家2的每一张1牌，玩家1都有一张比它更大的。\n如果把这$2k$个牌按大小排序，填上1或者2，发现它就是一个合法的括号序列。\n玩家1还剩下$m-k-k$张1牌。\n那么对于除了1牌的其它牌，玩家2不能被玩家1匹配的牌的数量之和应该恰好等于$m-k-k$。\n玩家2不能被玩家1匹配的牌，即为括号序列中，左括号比右括号多的情况。 有经典dp——$f[i][j]$表示前$i$个括号，有左括号比右括号多$j$个。可以得到： $$f[i][j]=f[i-1][j-1]+f[i-1][j+1]$$预处理这个dp。\n接下来考虑除了1牌之外，左括号比右括号一共多$x$张的方案。即一个背包DP，把$f[m][i]$当做物品做背包，体积为$i$。\n设$dp[i][j]$表示前$i$种非1牌，目前左括号比右括号多$j$个的方案，得到： $$dp[i][j]=\\sum_{x=0}^{j} dp[i-1][j-x]*f[m][x]$$枚举1牌的方案，玩家1比玩家2多$x$张牌，其实等价于把括号倒过来看，还是左括号比右括号多$x$张牌。\n最终$ans=\\sum_{x=0}^{m}f[m][x]*dp[n][x]$。\n实际上这个题目$n,m$可以做到$10^5$级别。\n首先是括号序列的dp。 前$m$个括号，有左括号比右括号多$i$个，等价于一个格路计数问题：\n左括号看做$(1,0)$,右括号看做$(0,1)$，走的时候不能碰到$y=x+1$这根直线，走到$(\\frac{m+i}{2},\\frac{m-i}{2})$这个坐标。可以用组合数直接得到答案，记为$a[i]$。\n第二个背包DP，用OGF的思想其实是$(\\sum_{i=0}^m a[i]x^i)^n$。多项式快速幂取前$m+1$项即可。\n主要代码（注释里是原数据规模）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 int Main() { int n, m; read(n, m); Combinatorics\u0026lt;modint\u0026gt; combinatorics(m + 1); auto reflection = [\u0026amp;](int x, int y) -\u0026gt; std::pair\u0026lt;int, int\u0026gt; { return {y - 1, x + 1}; }; std::vector\u0026lt;modint\u0026gt; a(m + 1); for (int i = m \u0026amp; 1; i \u0026lt;= m; i += 2) { int x = (m + i) / 2, y = (m - i) / 2; a[i] = combinatorics(x + y, x); std::tie(x, y) = reflection(x, y); if (x \u0026gt;= 0) a[i] -= combinatorics(x + y, x); // printf(\u0026#34;%d%c\u0026#34;, a[i], \u0026#34; \\n\u0026#34;[i == m]); } Poly f(a); Poly g = f.pow(n - 1, m + 1); modint ans = 0; for (int k = 0; k + k \u0026lt;= m; ++k) ans += g[m - k - k] * f[m - k - k]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; /*{ std::vector\u0026lt;modint\u0026gt; catalan(m + 1); catalan[0] = 1; for (int i = 1; i \u0026lt;= m; ++i) catalan[i] = catalan[i - 1] * (i * 4 - 2) * combinatorics.inv[i + 1]; std::vector s(m + 1, std::vector\u0026lt;modint\u0026gt;(m + 1)); std::vector\u0026lt;modint\u0026gt; f(m + 1); s[0][0] = 1; for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 0; j \u0026lt;= i; ++j) { if (j \u0026gt; 0) s[i][j] = s[i - 1][j - 1]; if (j + 1 \u0026lt;= i - 1) s[i][j] += s[i - 1][j + 1]; } } for (int i = 0; i \u0026lt;= m; ++i) f[i] = s[m][i]; std::vector dp(n + 1, std::vector\u0026lt;modint\u0026gt;(m + 1)); dp[1][0] = 1; for (int i = 2; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { for (int d = 0; d \u0026lt;= j; ++d) dp[i][j] += dp[i - 1][j - d] * f[d]; } } modint ans = 0; for (int k = 0; k + k \u0026lt;= m; ++k) ans += s[m][m - k - k] * dp[n][m - k - k]; printf(\u0026#34;%d\\n\u0026#34;, ans); }*/ return 0; } F 题目链接\n首先最终答案每个点代表的数只有0或者1。 证明：\n假设有一个数是2，说明被加了至少两次。把其中1次换成减法，可以得到更小的。\n于是最终一个点被操作了奇数次，则它的数是1；被操作偶数次，它的数是0. 这样就变成了一个奇偶性的判定。\n假设有一个随便的方案。某一个询问中两个点$x,y$，其数字分别是1和1，那么不妨把这个询问的操作换成相反的，得到0,0。\n而数字是(1,0)、(0,1)，再怎么换最终答案还是一样。\n然而假设有两个询问，在某一个点上重叠，状态分别是1,0,1。两询问的操作分别取反，得到0,0,0。\n这似乎跟图会有点关系。\n考虑用一个询问代表一条边，建出图。边的颜色要么是0要么是1。\n如果两个点$u,v$的数都是1，且$u,v$有一条路径相连，那么取反路径上每条边的颜色，只影响$u,v$两个点的值。\n这是一个经典问题，每两个值为1的点配对，路径染色，可以消掉一对1。 最终一个连通块里只有最多1个1。\n由于只需要$u,v$之间有路径，那么建出生成树即可。\n边的0,1染色就可以在树上用异或差分来实现。\n一开始给边随便定方向即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 struct DSU { public: DSU() : n(0) {} explicit DSU(int _n) : n(_n), parent_or_size(_n + 1, -1) {} int merge(int a, int b) { int x = leader(a), y = leader(b); if (x == y) return x; if (-parent_or_size[x] \u0026lt; -parent_or_size[y]) std::swap(x, y); parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x; return x; } bool same(int a, int b) { return leader(a) == leader(b); } int leader(int a) { if (parent_or_size[a] \u0026lt; 0) return a; return parent_or_size[a] = leader(parent_or_size[a]); } int size(int a) { return -parent_or_size[leader(a)]; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; groups() { std::vector\u0026lt;int\u0026gt; leader_buf(n + 1), group_size(n + 1); for (int i = 1; i \u0026lt;= n; i++) { leader_buf[i] = leader(i); group_size[leader_buf[i]]++; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result(n); for (int i = 1; i \u0026lt;= n; i++) { result[i].reserve(group_size[i]); } for (int i = 1; i \u0026lt;= n; i++) { result[leader_buf[i]].push_back(i); } result.erase( std::remove_if(result.begin(), result.end(), [\u0026amp;](const std::vector\u0026lt;int\u0026gt; \u0026amp;v) { return v.empty(); }), result.end()); return result; } private: int n; // root node: -1 * component size // otherwise: parent std::vector\u0026lt;int\u0026gt; parent_or_size; }; int Main() { int n, q; read(n, q); DSU dsu(n); std::vector adj(n + 1, std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt;{}); std::vector\u0026lt;int\u0026gt; d(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; edge(q + 1); std::vector sub(n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt;= q; ++i) { int u, v; read(u, v); if (!dsu.same(u, v)) { dsu.merge(u, v); adj[u].push_back({v, i}); adj[v].push_back({u, i}); } d[u] ^= 1; edge[i] = {u, v}; } for (int i = 1; i \u0026lt;= n; ++i) { if (d[i] == 1) sub[dsu.leader(i)].push_back(i); } std::vector status(q + 1, 0); std::vector tag(n + 1, 0); auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u, int fa) -\u0026gt; void { if (fa != 0) adj[u].erase(std::find_if(adj[u].begin(), adj[u].end(), [\u0026amp;](const std::array\u0026lt;int, 2\u0026gt; \u0026amp;cur) { return cur[0] == fa; })); for (auto [v, i] : adj[u]) { self(self, v, u); status[i] = tag[v]; tag[u] ^= tag[v]; } }; for (int i = 1; i \u0026lt;= n; ++i) { if (dsu.leader(i) != i) continue; auto \u0026amp;s = sub[i]; for (int j = 1; j \u0026lt; s.size(); j += 2) { int u = s[j - 1], v = s[j]; tag[u] ^= 1, tag[v] ^= 1; // printf(\u0026#34;%d %d\\n\u0026#34;, u, v); } dfs(dfs, i, 0); } for (int i = 1; i \u0026lt;= n; ++i) d[i] = 0; for (int i = 1; i \u0026lt;= q; ++i) { if (status[i]) std::swap(edge[i][0], edge[i][1]); auto [u, v] = edge[i]; printf(\u0026#34;%c%c\\n\u0026#34;, (status[i]) ? \u0026#39;y\u0026#39; : \u0026#39;x\u0026#39;, (d[u]) ? \u0026#39;-\u0026#39; : \u0026#39;+\u0026#39;); d[u] ^= 1; } return 0; } ","date":"2024-10-15T16:59:31+08:00","image":"https://rafakang.github.io/p/codeforces-educational-round-170-a~f%E9%A2%98%E8%A7%A3/background_hu267459029147378459.png","permalink":"https://rafakang.github.io/p/codeforces-educational-round-170-a~f%E9%A2%98%E8%A7%A3/","title":"Codeforces Educational Round 170 A~F题解"}]