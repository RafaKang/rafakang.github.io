[{"content":"CF2034A 题目链接\n题意 找一个最小的$m$使得，$m \\bmod a = m \\bmod b$\n解法 最小公倍数\n1 2 3 4 5 6 7 int Main() { int a, b; read(a, b); printf(\u0026#34;%d\\n\u0026#34;, std::lcm(a, b)); return 0; } CF2034B 题目链接\n题意 把一个01串进行若干次修改，使得不存在连续的$m$个0。一次修改可以把长度为$k$的一段修改成$k$个1\n解法 由贪心可知，如果出现连续的$m$个0，直接在最后一个0处修改即可。用双指针统计连续的$m$个0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int Main() { int n, m, k; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; std::string s; std::cin \u0026gt;\u0026gt; s; int cnt = 0; int ans = 0; for (int i = 0, j = 0; i + m - 1 \u0026lt; n;) { j = std::max(i, j); while (j - i + 1 \u0026lt;= m) cnt += s[j] == \u0026#39;1\u0026#39;, j++; if (cnt == 0) { i = j - 1; for (int x = i; x \u0026lt;= i + k - 1 \u0026amp;\u0026amp; x \u0026lt; n; ++x) s[x] = \u0026#39;1\u0026#39;; i = i + k; cnt = 0; ++ans; } else { cnt -= s[i] == \u0026#39;1\u0026#39;; i++; } } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } CF2034C 题目链接\n题意 有一个网格，有的点标记了上下左右四个方向，有的点没标记方向；现在问最多能使多少个点成环。\n解法 没标记方向的点相当于有上下左右四条待选边；直接DFS找环即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 int Main() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; auto index = [\u0026amp;](int x, int y) -\u0026gt; int { return m * (x - 1) + y; }; std::vector\u0026lt;int\u0026gt; vis(n * m + 1); std::vector\u0026lt;int\u0026gt; esc(n * m + 1); std::vector\u0026lt;std::string\u0026gt; s(n + 1); for (int i = 1; i \u0026lt;= n; ++i) std::cin \u0026gt;\u0026gt; s[i]; auto dfs = [\u0026amp;](this auto \u0026amp;\u0026amp;self, int x, int y) -\u0026gt; bool { if (x == 0 || x \u0026gt; n || y == 0 || y \u0026gt; m) return true; int u = index(x, y); if (vis[u]) return esc[u]; vis[u] = true; if (s[x][y - 1] == \u0026#39;R\u0026#39;) esc[u] = self(x, y + 1); if (s[x][y - 1] == \u0026#39;U\u0026#39;) esc[u] = self(x - 1, y); if (s[x][y - 1] == \u0026#39;L\u0026#39;) esc[u] = self(x, y - 1); if (s[x][y - 1] == \u0026#39;D\u0026#39;) esc[u] = self(x + 1, y); if (s[x][y - 1] == \u0026#39;?\u0026#39;) { bool ret = true; ret \u0026amp;= self(x, y + 1); ret \u0026amp;= self(x - 1, y); ret \u0026amp;= self(x, y - 1); ret \u0026amp;= self(x + 1, y); esc[u] = ret; } return esc[u]; }; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) if (!vis[index(i, j)]) dfs(i, j); } int ans = n * m - std::accumulate(esc.begin() + 1, esc.end(), 0); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } CF2034D 题目链接\n题意 有一个值为$0,1,2$的长为$n$的数组，需要把它排序；\n一次操作可以选择两个值相差不超过1的值，小的+1，大的-1。\n用不超过$n$个操作使数组排好序\n解法 排好序的数组不存在逆序对；因此按值域维护逆序对即可。\n由于题目的限制，只需要维护$2,1$逆序对和$1,0$逆序对。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); std::array\u0026lt;std::set\u0026lt;int\u0026gt;, 3\u0026gt; sets{}; for (int i = 1; i \u0026lt;= n; ++i) sets[a[i]].insert(i); std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; res{}; while (true) { if (sets[0].size() \u0026amp;\u0026amp; sets[1].size()) { int last0 = *sets[0].rbegin(), first1 = *sets[1].begin(); if (last0 \u0026gt; first1) { sets[1].erase(first1); sets[0].erase(last0); sets[1].insert(last0); sets[0].insert(first1); res.push_back({last0, first1}); continue; } } if (sets[1].size() \u0026amp;\u0026amp; sets[2].size()) { int last1 = *sets[1].rbegin(), first2 = *sets[2].begin(); if (last1 \u0026gt; first2) { sets[2].erase(first2); sets[1].erase(last1); sets[2].insert(last1); sets[1].insert(first2); res.push_back({last1, first2}); continue; } } break; } printf(\u0026#34;%d\\n\u0026#34;, res.size()); for (auto [i, j] : res) printf(\u0026#34;%d %d\\n\u0026#34;, i, j); return 0; } CF2034E 题目链接\n题意 构造$k$个排列，排成$k$行；每一列的和应该相等\n解法 $k=1$的时候只有$n=1$有解\n$k \u0026gt; n!$无解。\n接下来考虑每一列的和是多少？\n一行的总和固定为$n(n+1)/2$，$k$行总和为$kn(n+1)/2$\n所以一列的和为$k(n+1)/2$\n因此如果这个数不是整数，则无解。\n如果$k$是偶数显然有解——选择$k/2$个不相同的排列和他们的倒置排列即可。\n如果$k$是奇数？$n$也应该是奇数。$k=1$时无解（已特判）。\n$k=3$有解。特殊构造一下即可。\n如果$k=3$有解，那么$k=2x+3$也有解——直接接$x$个排列和它们的倒置排列即可。\n但是最后接到最开始的3个排列的倒置排列时，就无解了，因为此时列的和不相等。所以$k$为奇数，最多到$n!-3$才有解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 int Main() { int n, k; read(n, k); if (n == 1 \u0026amp;\u0026amp; k == 1) return printf(\u0026#34;YES\\n1\\n\u0026#34;), 0; if (n == 1 \u0026amp;\u0026amp; k != 1) return printf(\u0026#34;NO\\n\u0026#34;), 0; if (n != 1 \u0026amp;\u0026amp; k == 1) return printf(\u0026#34;NO\\n\u0026#34;), 0; if (1ll * (n + 1) * k % 2 != 0) return printf(\u0026#34;NO\\n\u0026#34;), 0; std::vector\u0026lt;int\u0026gt; mn(n + 1), mx(n + 1); std::iota(mn.begin(), mn.end(), 0); std::iota(mx.begin(), mx.end(), 0); std::reverse(mx.begin() + 1, mx.end()); if (k % 2 == 0) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; ans{}; ans.reserve(k); for (int i = 1; i \u0026lt;= k; i += 2) { if (mn \u0026gt;= mx) return printf(\u0026#34;NO\\n\u0026#34;), 0; ans.push_back(mn), ans.push_back(mx); std::next_permutation(mn.begin() + 1, mn.end()); std::prev_permutation(mx.begin() + 1, mx.end()); } printf(\u0026#34;YES\\n\u0026#34;); for (int i = 0; i \u0026lt; k; ++i) for (int j = 1; j \u0026lt;= n; ++j) printf(\u0026#34;%d%c\u0026#34;, ans[i][j], \u0026#34; \\n\u0026#34;[j == n]); } if (k % 2 == 1) { std::vector\u0026lt;int\u0026gt; p1(n + 1), p2(n + 1), p3(n + 1); p1 = mn; for (int i = 1; i \u0026lt;= (n - 1) / 2; ++i) p2[(n + 1) / 2 + i] = i; for (int i = (n + 1) / 2; i \u0026lt;= n; ++i) p2[i - (n - 1) / 2] = i; for (int i = 1; i \u0026lt;= (n + 1) / 2; ++i) p3[i] = n - (i - 1) * 2; for (int i = (n + 1) / 2 + 1; i \u0026lt;= n; ++i) p3[i] = (n - 1) - (i - (n + 1) / 2 - 1) * 2; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; ans{p1, p2, p3}; ans.reserve(k); while (ans.size() \u0026lt; k) { if (mn \u0026gt;= mx) return printf(\u0026#34;NO\\n\u0026#34;), 0; if (mn != p1 \u0026amp;\u0026amp; mn != p2 \u0026amp;\u0026amp; mn != p3 \u0026amp;\u0026amp; mx != p1 \u0026amp;\u0026amp; mx != p2 \u0026amp;\u0026amp; mx != p3) ans.push_back(mn), ans.push_back(mx); std::next_permutation(mn.begin() + 1, mn.end()); std::prev_permutation(mx.begin() + 1, mx.end()); } printf(\u0026#34;YES\\n\u0026#34;); for (int i = 0; i \u0026lt; k; ++i) for (int j = 1; j \u0026lt;= n; ++j) printf(\u0026#34;%d%c\u0026#34;, ans[i][j], \u0026#34; \\n\u0026#34;[j == n]); } return 0; } CF2034F1 题目链接\n题意 在第一象限上向右向上行走，$(0,0)$走到$(n,m)$。走一条横边的代价为2，竖边的代价为1。\n坐标上有$k$个特殊点，如果经过了一个特殊点，则之前路径的代价翻倍。\n问所有路径的总代价是多少。\n解法 考虑一条路径经过的特殊点$p_1,p_2,\u0026hellip;,p_x$。\n$p_i$和$p_{i-1}$这条路径的权值是确定的，但是路径数量有很多，具体来说是$p_{i-1}$不经过其它特殊点走到$p_{i}$的路径数，有经典容斥做法，对于单个起点效率是$O(k^2)$。\n因此设$dp[i]$为到特殊点$i$的路径权值总和，枚举之前经过的特殊点$j$，有转移$dp[i]+=2*f(j,i)(dp[j]+C_{x[j]+y[j]}^{y[j]}val(j-\u0026gt;i))$\n$f(j,i)$的计算对于单个$j$是$O(k^2)$的，因此总复杂为$O(k^3)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 int Main() { int n, m, k; read(n, m, k); std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; p(k + 2); p[0] = {0, 0}; for (int i = 1; i \u0026lt;= k; ++i) read(p[i].first, p[i].second); for (int i = 1; i \u0026lt;= k; ++i) p[i].first = n - p[i].first, p[i].second = m - p[i].second; p[k + 1] = {n, m}; std::vector dp(k + 2, modint{0}); dp[0] = 0; Combinatorics\u0026lt;modint\u0026gt; combinatorics(n + m + 1); std::sort(p.begin(), p.end()); auto ways = [\u0026amp;](int i, int j) { auto [x1, y1] = p[i]; auto [x2, y2] = p[j]; int dx = x2 - x1, dy = y2 - y1; if (dx \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026gt;= 0) return combinatorics(dx + dy, dx); return modint{0}; }; auto value = [\u0026amp;](int i, int j) { auto [x1, y1] = p[i]; auto [x2, y2] = p[j]; int dx = x2 - x1, dy = y2 - y1; if (dx \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026gt;= 0) return 2 * dx + dy; return 0; }; auto DP = [\u0026amp;](int x, int y, int s) -\u0026gt; std::vector\u0026lt;modint\u0026gt; { std::vector\u0026lt;modint\u0026gt; dp(k + 2, 0); for (int i = s; i \u0026lt;= k + 1; ++i) { dp[i] = ways(s, i); for (int j = s + 1; j \u0026lt; i; ++j) dp[i] -= dp[j] * ways(j, i); } return dp; }; for (int i = 0; i \u0026lt;= k; ++i) { auto [x, y] = p[i]; auto f = DP(x, y, i); // for (int j = 0; j \u0026lt;= k + 1; ++j) // printf(\u0026#34;%d%c\u0026#34;, f[j], \u0026#34; \\n\u0026#34;[j == k + 1]); for (int j = i + 1; j \u0026lt;= k + 1; ++j) dp[j] += dp[i] * 2 * f[j] + 2 * f[j] * value(i, j) * ways(0, i); } modint all = ways(0, k + 1); static modint inv2 = 998244354 \u0026gt;\u0026gt; 1; modint ans = dp[k + 1] * inv2 / all; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } CF2034F2 题目链接\n题意 在F1的基础上，$k=5000$\n解法 F1的容斥解法对F2毫无帮助。\n依然假设一条路径上的特殊点$p_1,p_2,\u0026hellip;,p_x$。\n这条路径的权值要怎么算？\n$\\sum_{i=1}^x (2(x[p_i]-x[p_{i-1}])+y[p_i]-y[p_{i-1}])\\times 2^{x-i + 1}$\n因为每个$p_i$被减一次被加一次，提取出来之后是\n$\\sum_{i=1}^x (2x[p_i]+y[p_i])*2^{x-i}$\n对于每个$p_i$，$(2x[p_i]+y[p_i])$这个值是确定的；所以我们要求的就是$p_i$在经过它的每条路径里面，$2^{x-i}$这个系数的和。\n接下来有一个很有趣的转化——$2^{x-i}=2^{x-i-1}+\u0026hellip;+2^0+1$。\n相当于一条路径上，$p_i$的系数，等价于$p_i$后面的点的系数之和+1。\n那么对于点$j$，如果它能出现在点$i$的后面，点$j$目前的所有路径给$j$的系数都能给点$i$，并且$j$到$i$的所有路径，每一条都能对应一个$j$的系数和。\n这就可以dp了。\n$dp[i]$是点$i$的系数，那么有转移$dp[i]+=dp[j]*C_{x[j]-x[i]+y[j]-y[i]}^{x[j]-x[i]}$\n最后把每个点的系数和权值贡献给答案。\n复杂度$O(k^2)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 int Main() { int n, m, k; read(n, m, k); std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; p(k + 2); p[0] = {0, 0}; for (int i = 1; i \u0026lt;= k; ++i) read(p[i].first, p[i].second); for (int i = 1; i \u0026lt;= k; ++i) p[i].first = n - p[i].first, p[i].second = m - p[i].second; p[k + 1] = {n, m}; std::vector dp(k + 2, modint{0}); // dp[k] = 1; Combinatorics\u0026lt;modint\u0026gt; combinatorics(n + m + 1); auto ways = [\u0026amp;](int i, int j) { auto [x1, y1] = p[i]; auto [x2, y2] = p[j]; int dx = x2 - x1, dy = y2 - y1; if (dx \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026gt;= 0) return combinatorics(dx + dy, dx); return modint{0}; }; std::sort(p.begin(), p.end()); modint ans = 0; for (int i = k + 1; i \u0026gt;= 0; --i) { dp[i] = ways(i, k + 1); for (int j = i + 1; j \u0026lt;= k; ++j) dp[i] += dp[j] * ways(i, j); ans += dp[i] * (2 * p[i].first + p[i].second) * ways(0, i); } modint all = ways(0, k + 1); ans /= all; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2024-12-12T12:40:06+08:00","image":"https://rafakang.github.io/p/vpcodeforces-round-989-a~f2/background_hu267459029147378459.png","permalink":"https://rafakang.github.io/p/vpcodeforces-round-989-a~f2/","title":"[VP]Codeforces Round 989 A~F2"},{"content":"T1编辑字符串 不难发现$t$字符串中连续的1，对应着$s$字符串中可以任意调整顺序的一个区间。\n那么相当于$s1,s2$有某些区间可以任意调整顺序，问最终能匹配上的最多位数是多少\n以下是我的贪心流程： 每一位$i$有4种情况——在$s1,s2$中都可以调；都不可以调；只在某一个字符串中可以调。\n不可以调的情况很简单，不多赘述。\n如果只在某一个字符串中可以调，假设在$s1$处可以调，相当于$s1[i]$是机动的，我们只需要调动它所在的调整区间中$s2[i]$这个字符到$s1[i]$这里就可以了，所以能匹配上的条件是该区间内还有$s2[i]$这个字符。\n如果都可以调，相当于$s1[i],s2[i]$都是机动的，那么任意取0或者1，只要两个字符串这个区间里都还有0或者1这个字符就可以了。\n由于$s1[i],s2[i]$都是机动的这个条件很宽松，优先匹配只在某一个字符串里可以调的情况，再处理$s1[i],s2[i]$都是机动的的情况即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 constexpr int MAXN = 1e5; char s1[MAXN + 5], s2[MAXN + 5]; char t1[MAXN + 5], t2[MAXN + 5]; int Main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); scanf(\u0026#34;%s%s%s%s\u0026#34;, s1 + 1, s2 + 1, t1 + 1, t2 + 1); std::vector\u0026lt;int\u0026gt; block1(n + 1), block2(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; sum1(n + 1), sum2(n + 1); for (int i = 1, cnt = 0; i \u0026lt;= n; ++i) { if (t1[i] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; t1[i - 1] == \u0026#39;1\u0026#39;) block1[i] = block1[i - 1]; else if (t1[i] == \u0026#39;1\u0026#39;) block1[i] = ++cnt; if (t1[i] == \u0026#39;1\u0026#39;) sum1[block1[i]][s1[i] - \u0026#39;0\u0026#39;]++; } for (int i = 1, cnt = 0; i \u0026lt;= n; ++i) { if (t2[i] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; t2[i - 1] == \u0026#39;1\u0026#39;) block2[i] = block2[i - 1]; else if (t2[i] == \u0026#39;1\u0026#39;) block2[i] = ++cnt; if (t2[i] == \u0026#39;1\u0026#39;) sum2[block2[i]][s2[i] - \u0026#39;0\u0026#39;]++; } int ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (t1[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t2[i] == \u0026#39;1\u0026#39;) { if (int \u0026amp;cnt = sum2[block2[i]][s1[i] - \u0026#39;0\u0026#39;]; cnt \u0026gt; 0) ans++, cnt--; } if (t1[i] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; t2[i] == \u0026#39;0\u0026#39;) { if (int \u0026amp;cnt = sum1[block1[i]][s2[i] - \u0026#39;0\u0026#39;]; cnt \u0026gt; 0) ans++, cnt--; } if (t1[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t2[i] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s2[i] == s1[i]) ans++; } for (int i = 1; i \u0026lt;= n; ++i) if (t1[i] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; t2[i] == \u0026#39;1\u0026#39;) { if (std::min(sum2[block2[i]][0], sum1[block1[i]][0]) \u0026gt; 0) ++ans, sum2[block2[i]][0]--, sum1[block1[i]][0]--; else if (std::min(sum2[block2[i]][1], sum1[block1[i]][1]) \u0026gt; 0) ++ans, sum2[block2[i]][1]--, sum1[block1[i]][1]--; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } int main() { freopen(\u0026#34;edit.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;edit.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); int TestCases = 1; if constexpr (MultiTestCases == 1) scanf(\u0026#34;%d\u0026#34;, \u0026amp;TestCases); while (TestCases--) Main(); return 0; } T2遗失的赋值 设序列是$s$\n假设$s_i$由一元关系固定，一个很关键的点是你可以让$a_i\\neq s_i$，这样后面你可以随便填（方案是$(v-1)v$。但是如果令$a_i=s_i$，那么$s_{i+1}$就根据你$b_i$的取值而确定，方案是$v$。\n如果当前$s_i$和$s_{i+1}$都不知道是多少，相当于上面两种方案都是可行的，因此方案是$v^2$。\n推广一下这个结论，两个相邻的$c_j$中间空出来很多$s_i$，相当于两头固定，但中间不确定的一个区间，假设这个区间是$[l,r]$。\n那么$a_l$如果等于$s_l$，$s_{l+1}$就固定了，且有$v$种固定它的方案，相当于区间长度缩小了一格，是一个子问题；如果$a_l\\neq s_l$，那么，这一位有$(v-1)v$种取值，且后面$[l+1,r-1]$所有的$s_i$都不知道，相当于$a,b$可以随便填；这样我们发现一个区间的方案跟两边的$s_l,s_r$取值无关，跟区间长度（或者说$a_i,b_i$数量）相关。\n$$dp[len]=v*dp[len-1]+(v-1)v*v^{2(len-1)}$$而序列长度$n\\leq 10^9$，线性DP可能超时。好在这个方程是$dp[i]$仅和$dp[i-1]$相关，考虑用矩阵加速。\n$$\\begin{bmatrix}dp[i-1],v(v-1)v^{2(i-1)} \\end{bmatrix} \\begin{bmatrix} v\u00260\\\\ 1\u0026v^2\\\\ \\end{bmatrix} = \\begin{bmatrix}dp[i],v(v-1)v^{2i} \\end{bmatrix}$$边界是$dp[1]=(v-1)v + 1$\n这样去遍历排好序的$c_j$序列，每次输入一个长度进去将转移矩阵$M$快速幂然后DP即可。\n这样可能会超时——因为10组测试数据共用1s，矩阵乘法计算一次需要8次运算。\n实际上没必要每次都去算矩阵的快速幂。单次计算一个向量和矩阵的乘法只需要4次操作，不妨预处理$M$的$2^i$次幂，这一步只需要算30次矩阵乘法。\n每次求一个长度的$dp$值的时候，直接用$\\begin{bmatrix}dp[1],v^3(v-1) \\end{bmatrix}$去乘对应的矩阵即可，运算常数减小为4，这个复杂度过题就很充裕了。\n另：展开之后可以直接得到公式$dp[i]=v^{2i}-v^{i}+v^{i-1}$，这就可以直接快速幂了\u0026hellip;\nemm，如果考场上展开比较烦的话用矩阵还是挺好的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 using modint = static_modint\u0026lt;(int)1e9 + 7\u0026gt;; template \u0026lt;class T, int SIZE = 2\u0026gt; struct Matrix { std::array\u0026lt;std::array\u0026lt;T, SIZE\u0026gt;, SIZE\u0026gt; a{}; Matrix(T v = 0) { for (int i = 0; i \u0026lt; SIZE; ++i) a[i][i] = v; } Matrix operator*(const Matrix \u0026amp;rhs) const { Matrix res{}; for (int i = 0; i \u0026lt; SIZE; ++i) for (int j = 0; j \u0026lt; SIZE; ++j) for (int k = 0; k \u0026lt; SIZE; ++k) res.a[i][j] += a[i][k] * rhs.a[k][j]; return res; } std::array\u0026lt;T, SIZE\u0026gt; \u0026amp;operator[](int i) { return a[i]; } const std::array\u0026lt;T, SIZE\u0026gt; \u0026amp;operator[](int i) const { return a[i]; } }; template \u0026lt;class T\u0026gt; T quick_pw(T a, ll b) { static T I{1}; if (b == 0) return I; T ans = I, base = a; while (b) { if (b \u0026amp; 1) ans = ans * base; b \u0026gt;\u0026gt;= 1; base = base * base; } return ans; } modint DP(int i, int v, const std::array\u0026lt;Matrix\u0026lt;modint\u0026gt;, 30\u0026gt; \u0026amp;trans) { i--; std::array\u0026lt;modint, 2\u0026gt; dp{modint{v - 1} * v + 1, modint{v} * (v - 1) * v * v}; for (int p = 0; p \u0026lt; 30; ++p) { if (i \u0026gt;\u0026gt; p \u0026amp; 1) { auto pre = dp; // printf(\u0026#34;%d %d\\n\u0026#34;, pre[0], pre[1]); dp[0] = pre[0] * trans[p][0][0] + pre[1] * trans[p][1][0]; dp[1] = pre[0] * trans[p][0][1] + pre[1] * trans[p][1][1]; } } return dp[0]; } int Main() { int n, m, v; read(n, m, v); modint v2 = 1ll * v * v; std::array\u0026lt;Matrix\u0026lt;modint\u0026gt;, 30\u0026gt; trans{}; trans[0][0][0] = v, trans[0][1][0] = 1; trans[0][0][1] = 0, trans[0][1][1] = v2; for (int i = 1; i \u0026lt; 30; ++i) trans[i] = trans[i - 1] * trans[i - 1]; std::map\u0026lt;int, int\u0026gt; map{}; bool flag = true; for (int i = 1; i \u0026lt;= m; ++i) { int c, d; read(c, d); if (map.count(c)) { if (map[c] != d) flag = false; } map[c] = d; } if (!flag) return printf(\u0026#34;0\\n\u0026#34;), 0; int pre = map.begin()-\u0026gt;first; modint ans = v2.pow(pre - 1); for (auto [c, _] : map) { int len = c - pre; if (len \u0026gt; 0) ans *= DP(len, v, trans); pre = c; } ans *= v2.pow(n - pre); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } int main() { freopen(\u0026#34;assign.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;assign.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); int TestCases = 1; if constexpr (MultiTestCases == 1) scanf(\u0026#34;%d\u0026#34;, \u0026amp;TestCases); while (TestCases--) Main(); return 0; } T3树的遍历 新树节点度数不超过3。\n换句话说：一条边它能扩展它的“兄弟边”（相邻）以及它的儿子边。\n假设一条边$(u,v)$，它的父亲有两种可能——$(x,u)$边以及$(u,y)$边。而边$(u,v)$能扩展的边也有两种——$(v,z)$边以及$(u,w)$边。\n于是考虑点$(u,v)$能和谁相连——假设它是$u$的儿子边中第$i$个扩展的，那么它可以扩展一个$v$的儿子边，以及$u$的儿子边中剩下一个没扩展的。\n它的方案数是$(d_v-1)*(d_u-i-1)$。于是你都乘起来发现答案是$\\prod(d_u-1)!$\n然后考虑$k=2$的情况。感觉上和这两个边中间的路径有关。\n考虑去重的情况。\n首先看一下起始边的情况——起始边一定度不超过2。\n这条红色边作为起始边，只会扩展左右两个虚线边。\n所以首先以$(u,v)$为起始边的新树$T1$，如果$(x,y)$在$T1$上的度数为2，则才有可能会重复。\n那么$(x,y)$何时度数为2？不妨考虑$(x,y)$的度数何时为3：此时，$(x,y)$会和$x$上两条边相连（其中一条扩展了$(x,y)$，而另一条则被$(x,y)$扩展），和$y$上一条边相连。\n所以你如果想让$(x,y)$在$T1$上度为2，那么$(x,y)$不能扩展出$x$的虚线边。等价于$x$的所有边中，这条红色的边是最后扩展的。\n于是重复计算了为$(d_x-2)!$次。\n再考虑黑边的情况。以$(w,x)$为例。\n这条边在以$(u,v)$为起始边的新树$T1$，它可能连接的有\n$(v,w)$或$w$的一条虚线 $w$的另一条虚线 $x$的虚线或$(x,y)$。 这条边在以$(x,y)$为起始边的新树$T2$，它可能连接的有\n$(x,y)$或$x$的一条虚线 $x$的另一条虚线 $w$的虚线或$(v,w)$。 如果这条边在新树$T1$中度为3，等于它和$w$中两条线相连，而这种情况在$T2$中不存在；反过来也是一样的，所以发生重复的情况一定也是这条边的度为2。\n那么重复计算次数为$(d_w-2)!$\n以此类推，最终总的重复数是$(d_v-2)!(d_w-2)!(d_x-2)!$。\n更形式化地讲：重复计算了$\\prod_{u\\in path{e_1,e_2}}(d_u-2)!$。\n重复计算？不禁让人想到容斥原理。\n所谓重复计算的部分，就是既能以$e_1$为起始边又能以$e_2$为起始边的方案。\n要求的是$|e_1 \\bigcup e_2|$，等价于$|e_1|+|e_2|-|e_1 \\bigcap e_2|$。\n进一步推广，对于$k$条边，求的是$|e_1|+\u0026hellip;+|e_k|-|e_1\\bigcap e_2|-|e_2\\bigcap e_3|\u0026hellip;+|e_1\\bigcap e_2\\bigcap e_3|+\u0026hellip;$\n这样我们化并为交，考虑求能以多条边为起始边的方案。偶数条边交在一起的方案减掉，奇数条边交在一起的方案加起来。\n考虑这样一张图： 两条黄色箭头指向的边，按上面的分析，分别要求在$e_1-\u0026gt;e_3$的新树和$e_1-\u0026gt;e_2$的新树中作为中间蓝点的最后一条边来扩展。那么以$e1,e2,e3$为起始边的共同方案在这一个点上出现了矛盾——两条不一样的边都要求是扩展的最后一条边，于是这种分岔的情况，交集的大小是0！\n而不分岔的情况，就是所有起始边都在同一条链上，这就方便我们统计了。\n写到这里我突然意识到，这种按边扩展的方式有点类似于左儿子右兄弟的树的变换方案。\n之前分析过一个点最多度数为3，有一个父亲和两个儿子；令它的左儿子连向它在树上的儿子边，那么右儿子相当于连接的是它的“兄弟边”。于是新树中，一条方向为右的右链对应了原树中从同一个点出发的所有边。\n一条右链$(a,b,c,d,e,f)$的大小，正是它们共同邻接点的度数。而由于dfs是从$a$的方向过来的，因此右链的一端固定为$a$；考虑不同的右链形态（或者叫“右链剖分”？），总方案是$\\prod(d_u-1)!$\n考虑$k=2$的情况实际上是，右链的另一头被固定了，所以右链形态变成了$(d_u-2)!$ 这张图上，$v$的虚边是右链上能随便移动的，刨去红边和黑边一共有$d_v-2$条边在右链上形态随意。\n所以为什么分岔的时候交集为0？因为你规定了两个右链的链尾，显然矛盾。\n所以我们最终要计数的是：一条以关键边为两端的路径$p$，权值为$\\prod_{u\\in p}\\frac{1}{d_u-1}$（因为总方案是$\\prod(d_u-1)!$，在这条路径上的点要变成$(d_u-2)!$，相当于除以一个$(d_u-1)$)。这条路径上除去两端仍有$q$条关键边，这些边可选可不选，每一种选法这条路径的权值都被重算一遍。\n注意到我们要做的是容斥。如果一种选法选了$x$关键边，如果$x$是偶数，由容斥系数是-1；反之容斥系数是1。那么我们只需要关注这条路径$p$上选奇数个边和偶数个边的选法，再乘上路径权重就可以。\n注意到我们统计的东西是一条路径的权值和路径上边的选法。对于树上路径的统计问题，有很多种做法，由于这里有求和，因此考虑直接树上DP。\n设$dp[u][0]、dp[u][1]$分别表示$u$子树向父亲方向选了偶数/奇数条路径的权值*选法之和。\n有$dp[u][0]=\\frac{1}{d_u-1}\\sum_{v\\in son(u)} dp[v][0], dp[u][1]=\\frac{1}{d_u-1}\\sum_{v\\in son(u)} dp[v][1]$\n另外：如果$u,v$是关键边，则加上这条边,让$\\frac{1}{d_u-1}(dp[v][0]+1)$也转移到$dp[u][1]$里，$\\frac{1}{d_u-1}dp[v][1]$也转移到$dp[u][0]$里。并且要注意在$u,v$处结算一条向下的路径，贡献加到$ans$里。\n然后在$u$处合并两个儿子的答案作为一条整路径的贡献加到$ans$里。 具体实现看代码。\n实际上有一个特别有意思的是：假设一条以关键边为两端的路径$p$，除去两端，路径上还有$q$个关键边，这条路径的点权积为$F$。\n看看这个$F$怎么向答案做贡献。\n枚举选择关键边的数量$i$，方案是$C_q^iF$，容斥系数为$(-1)^{i-1}$。所以贡献总数是$\\sum_{i=0}^q (-1)^{i-1}C_q^iF$。\n把这个式子乘一个$-1$进去，发现是$\\sum_{i=0}^q (-1)^{i}C_q^iF=F(1+(-1))^q=0$。\n所以实际上能为答案做贡献的，只有以关键边为两端，且中间再无其它关键边的路径，找这样的路径做统计就行（点分治、树上DP都可以做）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 using modint = static_modint\u0026lt;(int)1e9 + 7\u0026gt;; constexpr int MAXN = 1e5; int d[MAXN + 5]; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; adj[MAXN + 5]; std::array\u0026lt;modint, 2\u0026gt; dp[MAXN + 5]; int key[MAXN + 5]; modint fac[MAXN + 5], invfac[MAXN + 5], inv[MAXN + 5]; modint ans = 0; void init(int n) { std::fill(d + 1, d + n + 1, 0); std::fill(key + 1, key + n + 1, 0); std::fill(adj + 1, adj + n + 1, std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;{}); std::fill(dp + 1, dp + n + 1, std::array\u0026lt;modint, 2\u0026gt;{}); fac[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) fac[i] = fac[i - 1] * i; invfac[n] = fac[n].inv(); for (int i = n - 1; i \u0026gt;= 1; --i) invfac[i] = invfac[i + 1] * (i + 1), inv[i + 1] = fac[i] * invfac[i + 1]; inv[1] = 1; ans = 0; } void dfs(int u, int fa) { std::vector knakpack(2, std::array\u0026lt;modint, 2\u0026gt;{}); for (auto [v, i] : adj[u]) { if (v == fa) continue; dfs(v, u); std::array\u0026lt;modint, 2\u0026gt; f{}; f[0] = dp[v][0] * inv[d[u] - 1]; f[1] = dp[v][1] * inv[d[u] - 1]; if (key[i]) { ans -= dp[v][1], ans += dp[v][0]; f[0] += dp[v][1] * inv[d[u] - 1]; f[1] += dp[v][0] * inv[d[u] - 1] + inv[d[u] - 1]; } dp[u][0] += f[0], dp[u][1] += f[1]; ans -= knakpack[0][0] * f[0] + knakpack[0][1] * f[1]; ans += knakpack[0][1] * f[0] + knakpack[0][0] * f[1]; knakpack[1][0] = knakpack[0][0] + dp[v][0] + key[i] * dp[v][1]; knakpack[1][1] = knakpack[0][1] + dp[v][1] + key[i] * (dp[v][0] + 1); std::swap(knakpack[0], knakpack[1]); } } int Main() { int n, k; read(n, k); init(n); for (int i = 1; i \u0026lt; n; ++i) { int u, v; read(u, v); adj[u].push_back({v, i}), adj[v].push_back({u, i}); d[u]++, d[v]++; } for (int i = 1; i \u0026lt;= k; ++i) { int e; read(e); key[e] = 1; } dfs(1, 0); modint p = 1; for (int i = 1; i \u0026lt;= n; ++i) p *= fac[d[i] - 1]; ans *= p; ans += p * k; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } int main() { int c, TestCases = 1; if constexpr (MultiTestCases == 1) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;c, \u0026amp;TestCases); while (TestCases--) Main(); return 0; } T4树上查询 首先LCA具有一个优美的性质： $LCA([l,r])$是$a[i]=LCA(i,i+1)$中，$[l,r-1]$内深度最小的那个点。\n可以这样理解：\n$LCA([l,i-1])$和$i$的lca是$LCA([l,i])$。如果$LCA([l,i-1])\\neq LCA([l,i])$， $LCA([l,i])$一定是$i$和$[l,i-1]$其中某一个点的lca（其实都相同）。就让它等于$lca(i-1,i)$。\n所以当区间LCA发生变化的时候，一定是$i-1,i$的LCA跟之前的不一样，且变化成$i-1,i$的LCA。\n因此求出相邻两点的LCA放在$a[i]$里，在$[l,r-1]$上取最小即可。\n接下来发现查询是一个滑动窗口。\n根据CF212D的套路，可以用单调栈处理以$a[i]$为最小值的区间，假设它为$x[i],y[i]$。\n那么$a[i]$可以更新左端点在$[x[i],i]$，右端点在$[i, y[i]]$的滑动窗口的答案。\n这中间有一个$i$很讨厌，考虑放宽限制，如果窗口全落在$[x[i],i]$里，它的答案一定$\\geq a[i]$。因为根据单调栈的结论，这个区间的最小值比$a[i]$大。全落在右边是同样的结论。\n因此一个窗口只要落在$[x[i],y[i]]$里，答案就$\\geq a[i]$\n一个询问是在区间$[l,r]$里滑一个长为$k$的窗口，考虑它的答案是否能$\\geq a[i]$。那么在这里滑的窗口，需要落在$[x[i],y[i]]$里。\n等价于区间$[l,r]$和$[x[i],y[i]]$的交大于等于$k$。\n考虑交起来的情况：\n$x[i] \\leq l$，此时合法的区间为$y[i]\\geq l+k-1$ 扫描线处理$x[i]\\leq l$，在线段树上单点修改$y[i]$；然后查询$[l+k-1, n]$的最大值。 $x[i] \\geq l$， 此时合法的区间是$y[i]-x[i]+1\\geq k$且$r-x[i]+1\\geq k$。这一部分把区间和询问挂在“长度”上，倒序扫描长度，在$x[i]$处单点修改，在$[l, r-k+1]$查询最大值。 两遍扫描线即可更新所有答案。\n复杂度$O(nlog_2n)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 constexpr int MAXN = 5e5; std::vector\u0026lt;int\u0026gt; adj[MAXN + 5]; int fa[20][MAXN + 5], dep[MAXN + 5]; int st[20][MAXN + 5]; int a[MAXN + 5]; int lca(int u, int v) { if (dep[u] \u0026lt; dep[v]) std::swap(u, v); const int lg = 19; for (int i = lg; i \u0026gt;= 0; --i) if (dep[fa[i][u]] \u0026gt;= dep[v]) u = fa[i][u]; if (u == v) return u; for (int i = lg; i \u0026gt;= 0; --i) if (fa[i][u] != fa[i][v]) u = fa[i][u], v = fa[i][v]; return fa[0][u]; } void dfs(int u) { for (int p = 1; (1 \u0026lt;\u0026lt; p) \u0026lt;= dep[u]; ++p) fa[p][u] = fa[p - 1][fa[p - 1][u]]; for (int v : adj[u]) { if (v == fa[0][u]) continue; dep[v] = dep[u] + 1; fa[0][v] = u; dfs(v); } } int rmq(int l, int r) { int p = std::log2(r - l + 1); return std::max(st[p][l], st[p][r - (1 \u0026lt;\u0026lt; p) + 1]); } struct Segment { int l, r, w; }; Segment s[MAXN + 5]; struct Point { int p, w; }; int ans[MAXN + 5]; struct Query { int l, r, k; }; Query qry[MAXN + 5]; template \u0026lt;typename Info, typename Merge = std::plus\u0026lt;Info\u0026gt;\u0026gt; struct SegmentTree { const int n; const Merge merge; struct node { Info info; }; std::vector\u0026lt;node\u0026gt; tree; SegmentTree(int _n) : n(_n), merge(Merge()), tree(_n * 4 + 5) { } SegmentTree(std::vector\u0026lt;Info\u0026gt; \u0026amp;init, int _n) : SegmentTree(_n) { std::function\u0026lt;void(int, int, int)\u0026gt; build = [\u0026amp;](int p, int l, int r) { if (l == r) { tree[p].info = init[l]; return; } int mid = (l + r) / 2; build(p \u0026lt;\u0026lt; 1, l, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r); pull(p); }; build(1, 1, n); } void pull(int p) { tree[p].info = merge(tree[p \u0026lt;\u0026lt; 1].info, tree[p \u0026lt;\u0026lt; 1 | 1].info); } void modify(int p, int l, int r, int x, const Info \u0026amp;v) { if (l == r) return tree[p].info = merge(tree[p].info, v), void(); int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) modify(p \u0026lt;\u0026lt; 1, l, mid, x, v); else modify(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r, x, v); pull(p); } void modify(int p, const Info \u0026amp;v) { modify(1, 1, n, p, v); } Info query(int p, int l, int r, int x, int y) { if (l == x \u0026amp;\u0026amp; r == y) return tree[p].info; int mid = (l + r) \u0026gt;\u0026gt; 1; if (y \u0026lt;= mid) return query(p \u0026lt;\u0026lt; 1, l, mid, x, y); else if (x \u0026gt; mid) return query(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r, x, y); else return merge(query(p \u0026lt;\u0026lt; 1, l, mid, x, mid), query(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r, mid + 1, y)); } Info query(int l, int r) { return query(1, 1, n, l, r); } }; struct Merge { int operator()(int a, int b) const { return std::max(a, b); } }; void solve1(int n, int q) { std::vector\u0026lt;std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt;\u0026gt; ask(n + 1); // for (int i = qry[2].l; i \u0026lt;= qry[2].r - 1; ++i) // printf(\u0026#34;%d%c\u0026#34;, a[i], \u0026#34; \\n\u0026#34;[i == qry[2].r - 1]); for (int i = 1; i \u0026lt;= q; ++i) { auto [l, r, k] = qry[i]; if (k == 1) ans[i] = rmq(l, r); else { k--; ask[l].push_back({l + k - 1, n, i}); } } std::vector\u0026lt;std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt;\u0026gt; events(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { auto [l, r, w] = s[i]; events[l].push_back({r, w}); } SegmentTree\u0026lt;int, Merge\u0026gt; segment_tree(n); for (int i = 1; i \u0026lt;= n; ++i) { for (auto [r, w] : events[i]) segment_tree.modify(r, w); for (auto [l, r, id] : ask[i]) ans[id] = std::max(ans[id], segment_tree.query(l, r)); } } void solve2(int n, int q) { std::vector\u0026lt;std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt;\u0026gt; ask(n + 1); for (int i = 1; i \u0026lt;= q; ++i) { auto [l, r, k] = qry[i]; k--; ask[k].push_back({l, r - k, i}); } std::vector\u0026lt;std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt;\u0026gt; events(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { auto [l, r, w] = s[i]; events[r - l + 1].push_back({l, w}); } SegmentTree\u0026lt;int, Merge\u0026gt; segment_tree(n); for (int i = n; i \u0026gt;= 1; --i) { for (auto [l, w] : events[i]) segment_tree.modify(l, w); for (auto [l, r, id] : ask[i]) ans[id] = std::max(ans[id], segment_tree.query(l, r)); } } int Main() { int n; read(n); for (int i = 1; i \u0026lt; n; ++i) { int u, v; read(u, v); adj[u].push_back(v), adj[v].push_back(u); } dep[1] = 1; dfs(1); for (int i = 1; i \u0026lt;= n - 1; ++i) a[i] = dep[lca(i, i + 1)]; for (int i = 1; i \u0026lt;= n; ++i) st[0][i] = dep[i]; for (int p = 1; p \u0026lt;= 19; ++p) for (int i = 1; i + (1 \u0026lt;\u0026lt; p) - 1 \u0026lt;= n; ++i) { int j = i + (1 \u0026lt;\u0026lt; (p - 1)); st[p][i] = std::max(st[p - 1][i], st[p - 1][j]); } std::stack\u0026lt;int\u0026gt; stack{}; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; d(n + 1); for (int i = 1; i \u0026lt;= n - 1; ++i) { while (stack.size() \u0026amp;\u0026amp; a[stack.top()] \u0026gt;= a[i]) { s[stack.top()].r = i - 1; stack.pop(); } if (stack.size()) s[i].l = stack.top() + 1; else s[i].l = 1; stack.push(i); } while (stack.size()) s[stack.top()].r = n - 1, stack.pop(); for (int i = 1; i \u0026lt;= n - 1; ++i) s[i].w = a[i]; // for (int i = 1; i \u0026lt;= n - 1; ++i) //{ // printf(\u0026#34;%d %d %d\\n\u0026#34;, s[i].l, s[i].r, s[i].w); // } int q; read(q); for (int i = 1; i \u0026lt;= q; ++i) read(qry[i].l, qry[i].r, qry[i].k); solve1(n - 1, q); solve2(n - 1, q); for (int i = 1; i \u0026lt;= q; ++i) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); return 0; } int main() { int TestCases = 1; if constexpr (MultiTestCases == 1) scanf(\u0026#34;%d\u0026#34;, \u0026amp;TestCases); while (TestCases--) Main(); return 0; } ","date":"2024-12-01T13:22:02+08:00","permalink":"https://rafakang.github.io/p/noip2024/","title":"NOIP2024"},{"content":"CF2030A 题目链接\n题意 给出一个数组$a$，调整它的顺序，使得它每个前缀中的最大值减最小值的和最大\n解法 不难发现只要把前两个元素调整成整个数组的最大值和最小值就可以\n1 2 3 4 5 6 7 8 9 10 11 int Main() { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) std::cin \u0026gt;\u0026gt; a[i]; int mx = *std::max_element(a.begin() + 1, a.end()), mn = *std::min_element(a.begin() + 1, a.end()); std::cout \u0026lt;\u0026lt; (mx - mn) * (n - 1) \u0026lt;\u0026lt; std::endl; return 0; } CF2030B 题目链接\n题意 构造一个01串，使得只含0的非空子序列和包含至少1个1的非空子序列的差值绝对值最小\n解法 题目所求的两个数的差，实际上加起来就是非空子序列总数$2^n-1$。那么显然最小值就是1，即只含0的非空子序列是$2^{n-1}-1$，所以0的个数有$n-1$个。\n1 2 3 4 5 6 7 8 9 10 int Main() { int n; std::cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; ++i) putchar(\u0026#39;0\u0026#39;); putchar(\u0026#39;1\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); return 0; } CF2030C 题目链接\n题意 有$n$个布尔值常量，$A$和$B$轮流在常量中间放置操作符$and$和$or$。$and$的优先级更大。\n$A$希望最终结果是true，$B$希望最终结果是false。请问最终谁获胜。\n解法 $A$的决策是尽量放$or$，$B$的决策是尽量在0和1之间放$and$。\n假设$s[0]$是1，因为$A$是先手，那么$A$在$s[0]$和$s[1]$中间放一个$or$，这样无论$B$怎么放，运算到最后一步这第一个$or$的左边总是1。\n对于$s[n-1]$是1的情况是一样的。\n进一步，如果字符串中有两个1，先手在中间放一个$or$的话，后手想获胜必须用$and$消灭这两个1。然而后手在第一次操作只能最多消灭一个1，这样先手在另一边继续放一个$or$，形成$or\\ 1\\ or\\ 1$的局面；于是有一个1被保护住，那么最终答案一定是1。\n综上，先手必胜当且仅当出现两个连续的1，或者开头结尾是1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int Main() { int n; std::string s; std::cin \u0026gt;\u0026gt; n; std::cin \u0026gt;\u0026gt; s; for (int i = 1; i \u0026lt; n; i++) if (s[i - 1] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; s[i] == \u0026#39;1\u0026#39;) return printf(\u0026#34;YES\\n\u0026#34;), 0; if (s[0] == \u0026#39;1\u0026#39; || s[n - 1] == \u0026#39;1\u0026#39;) return printf(\u0026#34;YES\\n\u0026#34;), 0; printf(\u0026#34;NO\\n\u0026#34;); return 0; } CF2030D 题目链接\n题意 给出一个排列$p$和一个由$LR$组成的字符串$s$。\n如果$s[i]=L$，你可以交换$p[i]$和$p[i-1]$;\n如果$s[i]=R$，你可以交换$p[i]$和$p[i+1]$;\n现在给出$q$个操作，每次修改一个$s[i]$，问操作后整个排列是否能够通过上述交换方法来排序。\n解法 考虑面对一个字符串$s$的时候如何能够排好序。给排列排序的时候往往思考怎么交换。因为$p[i]$最终的位置是确定的。一次交换相当于断掉置换环上一条边。\n假设我们要交换两个位置$i\u0026lt;j$上的数，那么需要二者通过字符串指引的方向，能在中间相遇即可。即应该是$RRRRRLLLLL$这样的字符串。\n如果字符串出现了$LR$，相当于方向在中间断掉了，两个数就不能交换。\n因此需要判定$i$和$p[i]$是不是能交换，即$[min(i, p[i]), max(i, p[i])]$区间里是不是有$LR$这样的字符。\n具体地可以将影响交换的$LR$记录下来存在一个$set$里，每次修改的时候实际上改了两个位置，简单判断一下即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 char s[200005]; int Main() { int n, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); scanf(\u0026#34;%s\u0026#34;, s + 1); std::vector\u0026lt;int\u0026gt; vis(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { int l = std::min(i, p[i]), r = std::max(i, p[i]); vis[l]++, vis[r]--; } for (int i = 1; i \u0026lt;= n; ++i) vis[i] += vis[i - 1]; std::set\u0026lt;int\u0026gt; invalid{}; for (int i = 1; i \u0026lt; n; ++i) if (s[i] == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; vis[i] \u0026gt; 0) invalid.insert(i); while (q--) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); s[x] = (s[x] == \u0026#39;L\u0026#39;) ? \u0026#39;R\u0026#39; : \u0026#39;L\u0026#39;; if (vis[x]) { if (s[x + 1] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; s[x] == \u0026#39;L\u0026#39;) invalid.insert(x); else invalid.erase(x); } if (vis[x - 1]) { if (s[x] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; s[x - 1] == \u0026#39;L\u0026#39;) invalid.insert(x - 1); else invalid.erase(x - 1); } if (invalid.empty()) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } CF2030E 题目链接\n题意 假设数组$b$的分数是把$b$切分成若干个非空多重集，求这些多重集$MEX$和的最大值。\n现在给出一个长度为$n$的数组$a$，求它的所有非空子序列的分数和。\n解法 首先想面对一个数组$b$怎么计算分数。\n先把0都拿出来，假设有$k_0$个0，分成$k_0$个集合，那么现在至少得到了$k_0$分。\n接下来把1都拿出来，假设有$k_1$个1，分到原$k_0$个集合中去。如果$k_1\u0026lt;k_0$，那么我们多了$k_1$分；否则多了$k_0$分。即多了$min(k_0,k_1)$分。\n这样一看，可以按数字分层计算分数，每多一层，分数会多一个层内的数的前缀最小值。\n我的做法比较麻烦，当时做的时候有点上头了。\n设$score[i][j]$为前$i$层，且前$i$层，层内数最小值是$j$的分数和。\n看起来是$O(n^2)$的状态，但是实际上第$i$层不会放超过$cnt[i]$个数，$cnt[i]$为$a$数组中值为$i$的数的个数。因此状态是$O(n)$的。\n由于是按层算分数，那么第$i$层的分数为$j$*合法的方案数。设这个方案数为$dp[i][j]$。\n先考虑算$dp[i][j]$。\n有两种转移，第一种是最小值出现在第$i$层，那么就是$dp[i][j]=(\\sum_{x=j+1} dp[i-1][x])\\times C_{cnt[i]}^j$;第二种是最小值出现在前$i-1$层，那么$dp[i][j]+=(\\sum_{x=j+1}C_{cnt[i]}^x)\\times dp[i-1][j]$。后缀和简单优化一下就行了。\n接下来算$score[i][j]$，它是第$i$层的方案数乘前$i-1$层分数和第$i$层分数以及前i层总方案数。是一个差不多的转移。\n然后$i$枚举到整个数组的$mex$之后，后面的数可以出现在任意一个子序列里，还要再乘一个2的幂次。\n实际上每一层的分数都乘上后面2的剩下的数的幂次就把这一层对后面所有方案的贡献都累加了。只需要做一个$dp[i][j]$就行。\n不过无伤大雅，多写一个dp而已\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); std::sort(a.begin() + 1, a.end()); int mex = 0; for (int i = 1; i \u0026lt;= n; ++i) if (mex == a[i]) mex++; std::vector\u0026lt;int\u0026gt; cnt(n + 1); for (int i = 1; i \u0026lt;= n; ++i) cnt[a[i]]++; modint ans = 0; Combinatorics\u0026lt;modint\u0026gt; combinatorics(n + 1); std::vector sum(n + 1, std::vector\u0026lt;modint\u0026gt;{}); for (int i = 0; i \u0026lt;= mex; ++i) { sum[i].assign(cnt[i] + 1, 0); sum[i][0] = 1; for (int j = 1; j \u0026lt;= cnt[i]; ++j) sum[i][j] = sum[i][j - 1] + combinatorics(cnt[i], j); } std::vector dp(mex + 1, std::vector\u0026lt;modint\u0026gt;{}); std::vector sumdp(mex + 1, std::vector\u0026lt;modint\u0026gt;{}); std::vector\u0026lt;modint\u0026gt; score(n + 1); auto get_sum = [\u0026amp;](int i, int l, int r) -\u0026gt; modint { r = std::min(cnt[i], r); l = std::min(cnt[i], l); return sumdp[i][r] - sumdp[i][l]; }; int rem = n; for (int i = 0; i \u0026lt;= mex; ++i) { dp[i].assign(cnt[i] + 1, 0); sumdp[i].assign(cnt[i] + 1, 0); if (i == 0) { for (int j = 0; j \u0026lt;= cnt[i]; ++j) dp[i][j] = combinatorics(cnt[i], j); } else { dp[i][0] = dp[i - 1][0] * sum[i][cnt[i]]; for (int j = 1; j \u0026lt;= std::min(cnt[i - 1], cnt[i]); ++j) dp[i][j] = dp[i - 1][j] * (sum[i][cnt[i]] - sum[i][j - 1]); for (int j = 0; j \u0026lt;= cnt[i]; ++j) dp[i][j] += get_sum(i - 1, j, cnt[i - 1]) * combinatorics(cnt[i], j); } modint tmp = 0; if (i) { for (int j = cnt[i - 1]; j \u0026gt; cnt[i]; --j) { tmp += score[j]; score[j] = 0; } } for (int j = cnt[i]; j \u0026gt;= 1; --j) { tmp += score[j]; score[j] = (tmp - score[j]) * combinatorics(cnt[i], j) + score[j] * (sum[i][cnt[i]] - sum[i][j - 1]) + dp[i][j] * j; } score[0] = tmp + score[0] * sum[i][cnt[i]]; sumdp[i][0] = dp[i][0]; for (int j = 1; j \u0026lt;= cnt[i]; ++j) sumdp[i][j] = sumdp[i][j - 1] + dp[i][j]; rem -= cnt[i]; } ans = score[0]; ans *= modint(2).pow(rem); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } CF2030F 题目链接\n题意 玩过祖玛的就知道这其实就是祖玛。 相邻同色就能消灭，然后合并前后两段，依次做直到完全消除；\n现在问你某个区间是不是可完全消除的。\n解法 这题其实跟我做过的另一道题有点像。\n首先发现消除是有严格的先后顺序的。那么可行与否可以通过有向图的角度去思考\n假设$i$前面和它同色的是$j$，那么$[j+1,i-1]$都要先于$i，j$消除，可以连一条有向边。这个图成环的时候就不可行。\n什么时候成环？$i$和$j$连到$[j+1,i-1]$，而$j+1\\leq p \\leq i-1$又连到了$j$上。假设$p$前面同色是$q$，说明$[i, j]$和$[p,q]$相交了。\n称相邻同色之间构成的区间为同色区间，那么问题转变为给定查询区间，是否存在同色区间之间相交。\n由于没有修改操作，可以考虑按查询区间的某一个端点预处理一个结果。\n具体来说，可消除的区间具有单调性，假设以$r$为端点的极大可消除的区间左端点是$l$，那么$j\u0026gt;l$，$[j, r]$可消除；$j\u0026lt;l$, $[j, r]$不可消除；并且$l$对于$r$是单调递增的。\n那么可以考虑预处理出以每个$r$为右端点的最右可行左端点。从前往后枚举$r$，有点类似于扫描线一样在线段树上加入一个以$r$为右端点的区间左端点$pre[r]$；同时可行左端点向右滑动，当$[l, r]$中的左端点都大于$pre[r]$的时候停。\n需要注意的是相同颜色的区间可以交在同一个点上，因此这里判定区间相交指的是区间交集大于1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 int Main() { int n, q; read(n, q); std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); std::vector\u0026lt;int\u0026gt; pre(n + 1), last(n + 1); std::vector\u0026lt;int\u0026gt; suf(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { pre[i] = last[a[i]]; last[a[i]] = i; } for (int i = 1; i \u0026lt;= n; ++i) if (pre[i] == 0) pre[i] = i; std::vector\u0026lt;int\u0026gt; right_most(n + 1); struct Max { int operator()(int a, int b) const { return std::max(a, b); } }; SegmentTree\u0026lt;int, Max\u0026gt; segment_tree(n + 1); segment_tree.modify(pre[1], 1); right_most[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { right_most[i] = right_most[i - 1]; for (int \u0026amp;l = right_most[i]; l \u0026lt; pre[i]; l++) { auto res = segment_tree.query(l, pre[i] - 1); if (res \u0026lt;= pre[i]) break; } // printf(\u0026#34;%d\\n\u0026#34;, right_most[i]); if (pre[i] != 0) segment_tree.modify(pre[i], i); } std::vector\u0026lt;int\u0026gt; ans(q + 1); for (int i = 1; i \u0026lt;= q; ++i) { int l, r; read(l, r); if (l \u0026gt;= right_most[r]) ans[i] = true; else ans[i] = false; } for (int i = 1; i \u0026lt;= q; ++i) printf(\u0026#34;%s\\n\u0026#34;, ans[i] ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;); return 0; } CF2030G1 题目链接\n题意 给出若干个区间，你可以选择以1的代价向右或者向左拉长一个区间，拉长的长度为1。\n这些区间的分数为最小的使得所有区间都包含同一个点的代价。\n现在给出$n$个区间，问所有子序列的分数和。\n解法 又是这种，和E差不多的思路。先考虑给定若干区间怎么算分数。\n这里我的做法不太一样。\n考虑一个长度为1的小线段能为答案提供多少贡献。\n这个小线段假设左边有$l$个区间不包含它，右边有$r$个区间不包含它。因为终究是要包含到这个小线段，那么根据贪心思想，肯定是$min(l, r)$个区间向这个小线段的方向扩展。\n那么一个长度为1的小线段提供的贡献就是$min(l,r)$。把数轴上所有小线段枚举一遍就行了。\n接下来考虑原问题。\n发现一个小线段的代价跟左边右边不包含它的区间数量有关。考虑枚举左右不包含它的数量$l, r$。设左右不包含它的区间总数分别为$L, R$。\n那么代价就是$min(l,r)\\times C_L^l\\times C_R^r\\times 2^{n-L-R}$。\n现在枚举小线段的位置$i$，左右的$l,r$，复杂度是$O(n^3)$。\n考虑把$min(l,r)$拆开，变成两个式子：\n$2^{n-L-R}(\\sum_{l=0}^L l\\times C_L^l \\sum_{r=l+1}^R C_R^r) $\n$2^{n-L-R}(\\sum_{l=0}^L C_L^l \\sum_{r=0}^l r\\times C_R^r) $\n预处理组合数前缀和就行了。\nG2从这种做法很难优化；看来还是得用中位数的思路直接找最优的那个被包含的点，但是难点在于处理端点重合的部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 int Main() { int n; read(n); Combinatorics\u0026lt;modint\u0026gt; combinatorics(n + 1); std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; interval(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { auto \u0026amp;[l, r] = interval[i]; read(l, r); } std::vector\u0026lt;int\u0026gt; cntl(n + 1), cntr(n + 2); for (int i = 1; i \u0026lt;= n; ++i) { auto [l, r] = interval[i]; cntl[r]++, cntr[l]++; } for (int i = 1; i \u0026lt;= n; ++i) cntl[i] += cntl[i - 1]; for (int i = n; i \u0026gt;= 1; --i) cntr[i] += cntr[i + 1]; std::vector\u0026lt;int\u0026gt; incl(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { auto [l, r] = interval[i]; incl[l]++; incl[r]--; } for (int i = 1; i \u0026lt;= n; ++i) incl[i] += incl[i - 1]; std::vector\u0026lt;modint\u0026gt; bi(n + 1, 1); for (int i = 1; i \u0026lt;= n; ++i) bi[i] = bi[i - 1] * 2; std::vector sum1(n + 1, std::vector\u0026lt;modint\u0026gt;(n + 1)), sum2(n + 1, std::vector\u0026lt;modint\u0026gt;(n + 1)); for (int i = 0; i \u0026lt;= n; ++i) { sum1[i][0] = 1, sum2[i][0] = 0; for (int j = 1; j \u0026lt;= i; ++j) { sum1[i][j] = sum1[i][j - 1] + combinatorics(i, j); sum2[i][j] = sum2[i][j - 1] + combinatorics(i, j) * j; } for (int j = i + 1; j \u0026lt;= n; ++j) sum1[i][j] = sum1[i][j - 1], sum2[i][j] = sum2[i][j - 1]; } modint ans = 0; for (int i = 1; i \u0026lt;= n - 1; ++i) { modint sum = 0; for (int l = 0; l \u0026lt;= cntl[i]; ++l) { sum += l * combinatorics(cntl[i], l) * (bi[cntr[i + 1]] - sum1[cntr[i + 1]][l]); sum += combinatorics(cntl[i], l) * sum2[cntr[i + 1]][l]; // for (int r = 0; r \u0026lt;= l; ++r) // sum += combinatorics(cntl[i], l) * combinatorics(cntr[i + 1], r) * r; } sum *= bi[incl[i]]; ans += sum; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2024-11-06T15:38:06+08:00","image":"https://rafakang.github.io/p/vpcodeforces-round-979-a~g1/background_hu267459029147378459.png","permalink":"https://rafakang.github.io/p/vpcodeforces-round-979-a~g1/","title":"[VP]Codeforces Round 979 A~G1"},{"content":"CF2026A 题目链接\n题意 在一个第一象限$X\\times Y$的方格里，输出两条长度不小于$K$，且垂直的线段。数据保证有解。\n解法 直接模拟，从原点开始找长度不超过$K$的线段，判定它垂直方向上在不在方格里\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int Main() { int X, Y, K; read(X, Y, K); for (int x = 0; x \u0026lt;= X; ++x) { int y = sqrtl(K * K - x * x); while (y * y \u0026lt; K * K - x * x) y++; if (y \u0026gt; Y || y \u0026gt; x) continue; printf(\u0026#34;0 0 %d %d\\n\u0026#34;, x, y); printf(\u0026#34;0 %d %d 0\\n\u0026#34;, x, y); break; } return 0; } CF2026B 题目链接\n题意 有无穷大个白格子，其中有$n$个需要染色。你需要决定一个数值$k$，每次操作选择两个白格子$i$和$j$，且$|i-j|\\leq k$来染色。除了$n$个必须染色的格子外，最多可以多染1个。请问你决定的数值$k$最小是多少。\n解法 不难发现当$n$是偶数的时候，这个值就是相邻两个必染格子的最大差值。\n当$n$是奇数的时候，会有一个格子和多出来的染色格子一起染色。枚举这个格子，回到$n$是偶数的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 int Main() { int n; read(n); std::vector\u0026lt;ll\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); if (n % 2 == 0) { ll mx = 1; for (int i = 1; i \u0026lt;= n; i += 2) mx = std::max(a[i + 1] - a[i], mx); std::cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; std::endl; return 0; } ll ans = std::numeric_limits\u0026lt;ll\u0026gt;::max(); for (int i = 1; i \u0026lt;= n; ++i) { ll mx = 1; for (int j = 1; j \u0026lt;= n; j += 2) { if (j == i) j++; if (j \u0026gt; n) break; int nxt = j + 1; if (nxt == i) nxt++; mx = std::max(a[nxt] - a[j], mx); } ans = std::min(ans, mx); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } CF2026C 题目链接\n题意 你去买东西，第$i$天的商品花费$i$元。但是你能去商店的日子是有限的，用一个01串来表示。\n买超过两件商品有折扣，最贵的那件就不用付钱了。\n你想把每件商品买且仅买一件。问最少花多少钱。\n解法 因为最少花的钱等价于所有商品价值减去我省下的钱，因此考虑如何省更多钱。\n如果第$i$天能去商店，显然买两件以上商品，最多能省$i$元。不妨从后向前贪心。\n第$i$天如果能去商店，且能买两件商品，那么$i$天之前的商品与之前为了打折多买的前i天商品的差不小于2。\n维护这个多买的商品值。如果能买2件以上，则这个值增加1。如果$s[i]=0$，则这个值减1——因为相当于可以用这一天的商品抵消掉之前多买的，剩余多买的商品数少1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int Main() { int n; std::cin \u0026gt;\u0026gt; n; std::string s; std::cin \u0026gt;\u0026gt; s; int bought = 0; ll mx = 0; for (int i = n; i \u0026gt;= 1; --i) { if (s[i - 1] == \u0026#39;0\u0026#39;) { // bought = 0; if (bought \u0026gt; 0) bought--; } if (s[i - 1] == \u0026#39;1\u0026#39;) { if (i - bought \u0026gt;= 2) { mx += i; bought++; } } } std::cout \u0026lt;\u0026lt; 1ll * n * (n + 1) / 2 - mx \u0026lt;\u0026lt; std::endl; return 0; } CF2026D 题目链接\n题意 把$a$数组所有区间按左端点为第一关键字，右端点为第二关键字排序，得到新的数组$b$，数组的第$i$个元素是排名为$i$的区间的区间和。\n现有$q$个询问，每次询问给出一个$l,r$，询问$b$数组的$[l,r]$区间和。\n解法 前缀和套前缀和的套娃题。\n首先$b$数组可以写成一个二维表的形式。\n第$i$行，$n-i+1$个元素，表示左端点为$i$的区间和。\n当给出一个$l$的时候，可以等差数列+二分确定它在哪一行哪一列。对$r$是同理的。\n这样发现一个查询分为两种情况。\n$l$和$r$在同一行$i$；这种情况对应着左端点$i$相同、右端点连续的区间和。相当于$\\sum_{j=i+l}^{i+r}(sum[j]-sum[i])$，展开发现是前缀和的一段区间和减去$sum[i]$的一个倍数。那么预处理前缀和的前缀和就行了。\n$l$和$r$不在同一行。这对应着在$l$那一行的一段后缀和、在$r$那一行的一段前缀和、中间几行是满的；前两部分可以和上一种情况用同样的手法处理，中间满的几行可以预处理行$i$取满的值$row[i]=\\sum_{j=i}^n (sum[j]-sum[i])$，显然还是前缀和的前缀和处理一下，并且再求一个$row[i]$的前缀和。\n这样就全部解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); std::vector\u0026lt;ll\u0026gt; sum(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); for (int i = 1; i \u0026lt;= n; ++i) sum[i] = sum[i - 1] + a[i]; std::vector\u0026lt;ll\u0026gt; sum2(n + 1); for (int i = 1; i \u0026lt;= n; ++i) sum2[i] = sum2[i - 1] + sum[i]; std::vector\u0026lt;ll\u0026gt; row(n + 1); for (int i = 1; i \u0026lt;= n; ++i) row[i] = sum2[n] - sum2[i - 1] - 1ll * (n - i + 1) * sum[i - 1]; std::vector\u0026lt;ll\u0026gt; sumr(n + 1); for (int i = 1; i \u0026lt;= n; ++i) sumr[i] = sumr[i - 1] + row[i]; int q; read(q); auto find = [\u0026amp;](ll x) -\u0026gt; std::pair\u0026lt;int, int\u0026gt; { int l = 1, r = n; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (1ll * mid * (n + n - mid + 1) / 2 \u0026gt;= x) r = mid - 1; else l = mid + 1; } // printf(\u0026#34;find(%lld) = \u0026#34;, x); x -= 1ll * (l - 1) * (n + n - l + 2) / 2; // printf(\u0026#34;%lld %lld\\n\u0026#34;, l, x); return {l, x}; }; while (q--) { ll l, r; read(l, r); auto [r1, c1] = find(l); auto [r2, c2] = find(r); if (r1 == r2) { ll res = sum2[r1 - 1 + c2] - sum2[r1 - 1 + c1 - 1] - 1ll * (c2 - c1 + 1) * sum[r1 - 1]; printf(\u0026#34;%lld\\n\u0026#34;, res); } else { ll res = 0; if (r1 + 1 \u0026lt;= r2 - 1) res += sumr[r2 - 1] - sumr[r1]; res += sum2[n] - sum2[c1 - 2 + r1] - 1ll * (n - (r1 + c1 - 1) + 1) * sum[r1 - 1]; res += sum2[c2 + r2 - 1] - sum2[r2 - 1] - 1ll * c2 * sum[r2 - 1]; printf(\u0026#34;%lld\\n\u0026#34;, res); } } return 0; } CF2026E 题目链接\n题意 有$n$个数$a[i]$，选择一个子序列使得子序列的长度减去子序列的或和的$popcount$最大。\n解法 实际上换一种说法就是——如果取$a[i]$，得到1的收益，并且损失$popcount(a[i])$；同一位下的损失只计算一次。\n那么这实际上就是最大权闭合子图——把$a[i]$为1的位拿出来，把$i$向二进制上为1的位连边，$i$是正权，二进制位是负权，取了$a[i]$就得选这些为1的位。\n实际上构图出来是个二分图，算一下最小割，然后用正权和减一下即可。\n如果这个题每个数、每个位都带一个权重可能模型会更直白一点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 struct Flow { static constexpr int INF = 1e9; int n; struct Edge { int dest, cap; Edge(int dest, int cap) : dest(dest), cap(cap) {} }; std::vector\u0026lt;Edge\u0026gt; e; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g; std::vector\u0026lt;int\u0026gt; cur, h; Flow(int n) : n(n), g(n) {} bool bfs(int s, int t) { h.assign(n, -1); std::queue\u0026lt;int\u0026gt; que; h[s] = 0; que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int i : g[u]) { auto [v, c] = e[i]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == -1) { h[v] = h[u] + 1; if (v == t) return true; que.push(v); } } } return false; } int dfs(int u, int t, int f) { if (u == t) return f; int r = f; for (int \u0026amp;i = cur[u]; i \u0026lt; int(g[u].size()); ++i) { int j = g[u][i]; auto [v, c] = e[j]; if (c \u0026gt; 0 \u0026amp;\u0026amp; h[v] == h[u] + 1) { int a = dfs(v, t, std::min(r, c)); e[j].cap -= a; e[j ^ 1].cap += a; r -= a; if (r == 0) return f; } } return f - r; } void addEdge(int u, int v, int c) { g[u].push_back(e.size()); e.emplace_back(v, c); g[v].push_back(e.size()); e.emplace_back(u, 0); } ll flow(int s, int t) { ll ans = 0; while (bfs(s, t)) { cur.assign(n, 0); ans += dfs(s, t, INF); } return ans; } }; int Main() { int n; read(n); std::vector\u0026lt;ll\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); Flow graph(n + 60 + 2); int S = 0, T = n + 60 + 1; for (int p = 1; p \u0026lt;= 60; ++p) { for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] \u0026amp; (1ll \u0026lt;\u0026lt; (p - 1))) graph.addEdge(i, p + n, Flow::INF); } graph.addEdge(n + p, T, 1); } for (int i = 1; i \u0026lt;= n; ++i) graph.addEdge(S, i, 1); int cut = graph.flow(S, T); // printf(\u0026#34;%d\\n\u0026#34;, cut); std::cout \u0026lt;\u0026lt; n - cut \u0026lt;\u0026lt; std::endl; return 0; } CF2026F 题目链接\n题意 一开始有一个1号商店，接下来有$q$个操作。 $1\\ x$表示新开一个商店并复制$x$商店 $2\\ x\\ p\\ t$表示在商店$x$里加入一个容量为$p$，价值为$t$的商品 $3\\ x$把商店$x$最早加入的商品去除 $4\\ x\\ p$询问在商店$x$花费$p$元钱最多能买多少价值的商品\n解法 如果没有1操作，就是在一个队列上一边push元素一边pop元素，询问是在队头和队尾中间做01背包。\n有1操作的情况下，就是在可持久化队列里做01背包。\n由于没有强制在线可以考虑离线。\n在真正解决这个问题之前，先考虑三个前置问题。\n在栈上做背包 在栈上push一个元素，或者pop掉栈顶，并维护背包的DP值。\n由于背包的DP，$dp[i][j]$从$dp[i-1][j]$和$dp[i-1][j-v[i]]$转移过来。\n那么正常做背包的过程就相当于不断push一个元素，更新dp数组。\n当pop掉栈顶的时候，等价于最后一个元素被移除了，这时我们让$n$（代表物品数量）直接变回$n-1$，取$dp[n-1]$的DP值就好。\n在队列上做背包 相比在栈上做背包，在队列上做背包的难点是移除了最开头的元素。\n如果移除的是末尾的元素，那么非常好做。\n为了解决这个问题，可以想象目前在队头和队尾中间有一条线。\n考虑维护左右两个dp数组，分别叫$dpl$和$dpr$。\n$dpr$从红线向队尾按正向推，$dpl$从红线向队头按逆向推。\n这样队列pop元素的时候，相当于从$dpl$移除末尾的一层，就很好做了。\n如果$dpl$空了，就考虑重新画线在队尾处，将$dpl$重新算一遍并且清空$dpr$。\n这样看起来复杂度好像很高。但是考虑一个物品会在哪里做DP。\n一个物品会在正向的$dpr$数组里通过push操作做一层DP，并且重构$dpl$的时候会在逆向的$dpl$数组里做一层DP。于是总的DP层数不超过$2n$。\n在回答一个询问的时候，合并$dpl$和$dpr$两个数组。具体来说就是枚举左右的体积$i$和$V-i$，加起来求最大值即可。\n于是复杂度是$O(nV+qV)$\n在双端队列上做背包 这个问题相比上一个问题，在队头和队尾处都会增加、删除元素。\n不过与普通队列相比，增删元素都是在对应的dp数组末尾增加或移除一层，复杂度是不变的。\n问题在于重构操作。假设依旧是某一边空了，直接重构，将另一边清空的情况。\n可能会出现左空，pop左，全部重构到左边；然后pop右，全部重构到右边；接下来再次pop左，全部重构到左边\u0026hellip;这样左右横跳的操作。\n假设重构并不清空一边，而是重画一条线，考虑这条线画在哪里。一般来说为了避免上述情况会画在队头和队尾的中间。这样做的时间复杂度是怎样的呢？\n以下是我个人比较民科的思考：\n假设当前队列有$x$个元素，那么重构一次左右两边分别有$\\frac{x}{2}$个元素。\n距离下一次重构可能发生的事情是，某一边空了，另一边被塞了$k$个数。\n于是在某一边净pop一共$\\frac{x}{2}$次，对这一边的总操作次数必然大于等于它；在另一边净push一共$k$次，对这一边总操作次数也必然大于等于它。\n那么下一次重构操作一共做了$O(k+\\frac{x}{2})$层DP。\n于是我们发现这两次重构操作之间的操作数$\\geq k+\\frac{x}{2}$。那么一次重构操作的DP层数，小于等于它和上一次重构操作之间的距离，相当于一个差分！\n那么重构的总DP层数，等价于最后一次重构到一开始之间的操作数，不会超过总操作数$n$。\n所以在双端队列这样重构的复杂度是$O(nV)$的。$n$是总操作数。\n至于其它操作和普通队列复杂度是等价的。\n因此最终复杂度依然是$O(nV+qV)$\n本题的解法 把所有操作离线，按NOIP2023三值逻辑的拆点方案，做一棵版本树。\n每一次复制、增加、删除操作都是新增一个节点，并接在原节点上。把具体的操作参数写在父亲向儿子的边上。\n询问操作就挂在对应版本对应的节点上。\n这样自顶向下DFS的过程，相当于从后push、从前pop的队列背包。\n而DFS的回溯过程，相当于从后pop、从前push的队列背包。\n两者形成了一个双端队列背包。\n于是在DFS这棵版本树的过程中，维护双端队列背包，询问时直接给出答案即可。\n由上一节的结论，总复杂度是$O(qP)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 int Main() { int q; read(q); std::vector adj(q + 1, std::vector\u0026lt;int\u0026gt;{}); std::vector last(q + 1, 0); int n = 1, m = 1; last[1] = 1; std::vector upd(q + 1, std::array\u0026lt;int, 2\u0026gt;{}); std::vector qry(q + 1, std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt;{}); int cnt = 0; while (q--) { int op; read(op); if (op == 1) { int x; read(x); m++; last[m] = last[x]; } if (op == 2) { int x, p, t; read(x, p, t); int u = last[x]; int v = ++n; adj[u].push_back(v); last[x] = v; upd[v] = {p, t}; } if (op == 3) { int x; read(x); int u = last[x]; int v = ++n; adj[u].push_back(v); last[x] = v; upd[v] = {-1, -1}; } if (op == 4) { int x, p; read(x, p); cnt++; qry[last[x]].push_back({p, cnt}); } } const int P = 2000; std::vector dpL(1, std::vector\u0026lt;int\u0026gt;(P + 1)); std::vector dpR(1, std::vector\u0026lt;int\u0026gt;(P + 1)); std::deque\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; dq{}; std::vector\u0026lt;int\u0026gt; ans(cnt + 1); auto DP = [\u0026amp;](std::vector\u0026lt;int\u0026gt; \u0026amp;pre, int p, int t) -\u0026gt; std::vector\u0026lt;int\u0026gt; { std::vector\u0026lt;int\u0026gt; dp(P + 1); for (int v = 0; v \u0026lt;= P; ++v) { dp[v] = pre[v]; if (v \u0026gt;= p) dp[v] = std::max(dp[v], pre[v - p] + t); } return dp; }; auto rebuild = [\u0026amp;]() { int size = dq.size(); int l = size / 2, r = size - l; dpL.assign(l + 1, std::vector\u0026lt;int\u0026gt;(P + 1)); dpR.assign(r + 1, std::vector\u0026lt;int\u0026gt;(P + 1)); for (int i = 1; i \u0026lt;= r; ++i) { auto [p, t] = dq[l + i - 1]; dpR[i] = DP(dpR[i - 1], p, t); } for (int i = 1; i \u0026lt;= l; ++i) { auto [p, t] = dq[l - i]; dpL[i] = DP(dpL[i - 1], p, t); } }; auto query = [\u0026amp;](int V, int i) { auto \u0026amp;dp0 = dpL.back(); auto \u0026amp;dp1 = dpR.back(); int res = 0; for (int i = 0; i \u0026lt;= V; ++i) res = std::max(res, dp0[i] + dp1[V - i]); ans[i] = res; }; auto pop_front = [\u0026amp;]() { dq.pop_front(); if (dpL.size() == 1) rebuild(); else dpL.pop_back(); }; auto push_front = [\u0026amp;](int p, int t) { dq.push_front({p, t}); auto dp = DP(dpL.back(), p, t); dpL.push_back(dp); }; auto pop_back = [\u0026amp;]() { dq.pop_back(); if (dpR.size() == 1) rebuild(); else dpR.pop_back(); }; auto push_back = [\u0026amp;](int p, int t) { dq.push_back({p, t}); auto dp = DP(dpR.back(), p, t); dpR.push_back(dp); }; auto dfs = [\u0026amp;](this auto \u0026amp;\u0026amp;self, int u) -\u0026gt; void { auto [p, t] = upd[u]; if (p \u0026lt; 0) { std::tie(p, t) = dq.front(); p = -p; pop_front(); } else if (p \u0026gt; 0) push_back(p, t); for (auto [V, i] : qry[u]) query(V, i); for (int v : adj[u]) self(v); if (p \u0026lt; 0) { push_front(-p, t); } else if (p \u0026gt; 0) pop_back(); }; dfs(1); for (int i = 1; i \u0026lt;= cnt; ++i) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); return 0; } ","date":"2024-10-30T17:41:55+08:00","image":"https://rafakang.github.io/p/codeforces-edu-round-171-a~f%E9%A2%98%E8%A7%A3/background_hu267459029147378459.png","permalink":"https://rafakang.github.io/p/codeforces-edu-round-171-a~f%E9%A2%98%E8%A7%A3/","title":"Codeforces Edu Round 171 A~F题解"},{"content":"CF2033A 题目链接\n题意 数轴上原点有一个黑点，A和B两个人轮流操作，第$i$次操作移动黑点$2i-1$的距离，A往负数方向操作，B往正数操作，问谁能把它操作出距离原点$N$的距离。\n解法 看一下样例就知道答案根据$N$的奇偶性变化。或者直接模拟也行。\n1 2 3 4 5 6 7 8 9 10 int Main() { int n; read(n); if (n % 2 == 1) printf(\u0026#34;Kosuke\\n\u0026#34;); else printf(\u0026#34;Sakurako\\n\u0026#34;); return 0; } CF2033B 题目链接\n题意 一个$n\\times n$的棋盘，棋盘上的数有正有负，一次操作可以选一个子矩阵，然后把对角线都加1。问最少多少次操作所有数都是正数。\n解法 不难发现每次选长到不能再长的$45°$线来操作，操作次数就是这条线所有负数的最小值。这样枚举线求个最小值即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int Main() { int n; read(n); std::vector diag(n + n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) { int a; read(a); diag[i - j + n].push_back(a); } int ans = 0; for (int i = 0; i \u0026lt; n + n + 1; ++i) { if (diag[i].size() == 0) continue; int mn = *std::min_element(diag[i].begin(), diag[i].end()); if (mn \u0026gt;= 0) continue; ans -= mn; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } CF2033C 题目链接\n题意 一个数组$a$，每次可以交换$a[i]$和$a[n-i+1]$，问所有操作后，最少有多少$a[i]=a[i+1]$。\n解法 对同一个位置交换两次显然等价于不交换。那么每一个位置的决策要么交换要么不交换，一个线性dp即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 2); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); const int INF = 1e9; std::vector dp(n + 1, std::array\u0026lt;int, 2\u0026gt;{INF, INF}); dp[0][0] = 0; for (int i = 1; i \u0026lt;= n \u0026amp;\u0026amp; i \u0026lt;= n - i + 1; ++i) { dp[i][0] = dp[i - 1][0] + (a[i] == a[i - 1]) + (a[n - i + 1] == a[n - i + 2]); dp[i][1] = dp[i - 1][0] + (a[i] == a[n - i + 2]) + (a[n - i + 1] == a[i - 1]); dp[i][0] = std::min(dp[i][0], dp[i - 1][1] + (a[i] == a[n - i + 2]) + (a[n - i + 1] == a[i - 1])); dp[i][1] = std::min(dp[i][1], dp[i - 1][1] + (a[i] == a[i - 1]) + (a[n - i + 1] == a[n - i + 2])); } int last = (n + 1) / 2; printf(\u0026#34;%d\\n\u0026#34;, std::min(dp[last][0], dp[last][1]) + ((n % 2 == 0) ? a[last] == a[last + 1] : 0)); return 0; } CF2033D 题目链接\n题意 一个数组最多能分出来多少个不相交并且区间和为0的区间。\n解法 经典dp，用$dp[i]$表示分到$i$时最多区间数，两种决策，是否把$i$作为右端点。\n$dp[i]=max(dp[i-1],dp[j]+1(sum[i]-sum[j]=0))$。 用桶存储下标为$sum[i]$的最大$dp[i]$即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); std::vector\u0026lt;ll\u0026gt; sum(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { read(a[i]); sum[i] = sum[i - 1] + a[i]; } std::map\u0026lt;ll, int\u0026gt; buc{}; std::vector dp(n + 1, 0); buc[0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (buc.count(sum[i])) dp[i] = buc[sum[i]] + 1; dp[i] = std::max(dp[i - 1], dp[i]); buc[sum[i]] = std::max(buc[sum[i]], dp[i]); } int ans = *std::max_element(dp.begin(), dp.end()); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } CF2033E 题目链接\n题意 一个排列，可以交换任意两个数。问最少多少次操作后能使得$p_i=i$或者$p_{p_i}=i$。\n解法 根据置换环理论，就是要把所有大于2的环都变成长度为1或者2的。 一次交换相当于改边。那么在每次把环上点的后继和点的前继交换一下即可。一次操作吧一个环的点数减2。对于一个长度为$l$的环，操作次数就是$\\frac{l+1}{2}-1$，因为最后等于4或者3的时候只需要一次操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; p(n + 1); std::vector\u0026lt;int\u0026gt; vis(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(p[i]); auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u) -\u0026gt; int { if (vis[u]) return 0; vis[u] = true; int ret = self(self, p[u]); return ret + 1; }; int ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (vis[i]) continue; int cnt = dfs(dfs, i); ans += (cnt + 1) / 2 - 1; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } CF2033F 题目链接\n题意 给出$n$和$k$,求斐波那契数列上第$n$个能被$k$整除的数是第几个。\n解法 手玩几组样例可以发现，这个模$k$的斐波那契数列存在循环节。于是目标是找到循环节。\n这取模的斐波那契数列的循环节的学名叫做皮萨诺周期，一个听起来让人有点饿的名字。\nOEIS链接：https://oeis.org/A001175\n实际上皮萨诺周期的长度不会超过$6k$，于是暴力求解出循环节，以及循环节里的0的数量，除一下再算循环节内的下标即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int Main() { ll n; int k; read(n, k); const int P = 1000000007; if (k == 1) return printf(\u0026#34;%lld\\n\u0026#34;, n % P), 0; ll cycle = 0; int cnt = 0; std::vector\u0026lt;int\u0026gt; idx{}; for (int i = 3, f1 = 1, f2 = 1; i \u0026lt;= 10 * k + 5; ++i) { f1 = (f2 + f1) % k; std::swap(f1, f2); if (f2 == 0) idx.push_back(i); if (f1 == 1 \u0026amp;\u0026amp; f2 == 0) { cycle = i; break; } } ll ans = (n / idx.size()) % P; ans = ans * cycle % P; if (n % idx.size()) ans += idx[n % idx.size() - 1] % P; ans %= P; std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } CF2033G 题目链接\n题意 有一棵以1为根的树，从节点$a$向子节点走不花费体力，向父亲走花费1单位的体力。\n现在有$q$个询问，每次询问给出$v,k$，问从$v$开始，花费不超过$k$的体力最远能走多远。\n解法 考虑一条路径$(u,v)$的长度和它的花费。\n设$dep[u]$为节点深度，长度是$dep[u]+dep[v]-2dep[LCA(u,v)]$,花费是$dep[u]-dep[LCA(u,v)]$。\n要让花费不超过$k$，即在$u$的$k$级祖先以内，找到除$u$这棵子树之外的最长向下的链。\n我的做法是离线，把操作挂到点上之后dfs。dfs时，维护一棵线段树，下标是节点深度，存储最长的向下的链。\n从$u$换根到$v$时，用$v$兄弟子树内最大的节点深度去更新线段树$dep[u]$处的值。\n一开始将题意看反了，往下走有花费，但是往上走没花费。做法大差不差。可以思考一下。\n这样的话用子树内最长的向下链长度做线段树下标，存储的值是节点深度。 查询的时候分两步查，第一步查$[0,k]$之内最长链和节点深度的差的最大值，第二步查$[k+1,n]$之内节点深度的最小值并用k减掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 template \u0026lt;typename Info, typename Merge = std::plus\u0026lt;Info\u0026gt;\u0026gt; struct SegmentTree { const int n; const Merge merge; struct node { Info info; }; std::vector\u0026lt;node\u0026gt; tree; SegmentTree(int _n) : n(_n), merge(Merge()), tree(_n * 4 + 9) { } SegmentTree(std::vector\u0026lt;Info\u0026gt; \u0026amp;init, int _n) : SegmentTree(_n) { std::function\u0026lt;void(int, int, int)\u0026gt; build = [\u0026amp;](int p, int l, int r) { if (l == r) { tree[p].info = init[l]; return; } int mid = (l + r) / 2; build(p \u0026lt;\u0026lt; 1, l, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r); pull(p); }; build(1, 0, n); } void pull(int p) { tree[p].info = merge(tree[p \u0026lt;\u0026lt; 1].info, tree[p \u0026lt;\u0026lt; 1 | 1].info); } void modify(int p, int l, int r, int x, const Info \u0026amp;v) { if (l == r) return tree[p].info = v, void(); int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) modify(p \u0026lt;\u0026lt; 1, l, mid, x, v); else modify(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r, x, v); pull(p); } void modify(int p, const Info \u0026amp;v) { modify(1, 0, n, p, v); } Info query(int p, int l, int r, int x, int y) { if (l == x \u0026amp;\u0026amp; r == y) return tree[p].info; int mid = (l + r) \u0026gt;\u0026gt; 1; if (y \u0026lt;= mid) return query(p \u0026lt;\u0026lt; 1, l, mid, x, y); else if (x \u0026gt; mid) return query(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r, x, y); else return merge(query(p \u0026lt;\u0026lt; 1, l, mid, x, mid), query(p \u0026lt;\u0026lt; 1 | 1, mid + 1, r, mid + 1, y)); } Info query(int l, int r) { return query(1, 0, n, l, r); } }; int Main() { int n; read(n); std::vector adj(n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt; n; ++i) { int u, v; read(u, v); adj[u].push_back(v), adj[v].push_back(u); } std::vector\u0026lt;int\u0026gt; mxdep(n + 1), dep(n + 1); std::function\u0026lt;void(int, int)\u0026gt; dfs = [\u0026amp;](int u, int fa) -\u0026gt; void { if (fa != 0) adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa)); dep[u] = dep[fa] + 1; mxdep[u] = dep[u]; for (int v : adj[u]) { dfs(v, u); mxdep[u] = std::max(mxdep[u], mxdep[v]); } }; dfs(1, 0); std::vector\u0026lt;int\u0026gt; pre(n + 1), suf(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { int mx = 0; for (int j = 0; j \u0026lt; adj[i].size(); ++j) { int v = adj[i][j]; pre[v] = mx; mx = std::max(mxdep[v], mx); } mx = 0; for (int j = adj[i].size() - 1; j \u0026gt;= 0; --j) { int v = adj[i][j]; suf[v] = mx; mx = std::max(mxdep[v], mx); } } std::vector qry(n + 1, std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;{}); int q; read(q); std::vector\u0026lt;int\u0026gt; ans(q + 1); for (int i = 1; i \u0026lt;= q; ++i) { int v, k; read(v, k); qry[v].push_back({k, i}); } struct Info { int p; int mx; int sum; }; struct Merge { Info operator()(const Info \u0026amp;lhs, const Info \u0026amp;rhs) const { Info res; res.p = lhs.p; res.mx = std::max(lhs.mx, rhs.mx); res.sum = std::max(lhs.sum, rhs.sum); return res; } }; std::vector\u0026lt;Info\u0026gt; init(n + 1); for (int i = 0; i \u0026lt;= n; ++i) init[i] = {i, 0, -i}; SegmentTree\u0026lt;Info, Merge\u0026gt; segment_tree(init, n); std::function\u0026lt;void(int)\u0026gt; reroot = [\u0026amp;](int u) { for (auto [k, i] : qry[u]) { ans[i] = std::max(mxdep[u] - dep[u], ans[i]); ans[i] = std::max(ans[i], dep[u] + segment_tree.query(std::max(1, dep[u] - k), dep[u]).sum); } for (int v : adj[u]) { int mx = std::max({dep[u], pre[v], suf[v]}) - dep[u]; Info cur = segment_tree.query(dep[u], dep[u]); Info next = Merge{}(cur, {dep[u], mx, -dep[u] + mx}); segment_tree.modify(dep[u], next); reroot(v); segment_tree.modify(dep[u], cur); } }; reroot(1); for (int i = 1; i \u0026lt;= q; ++i) printf(\u0026#34;%d%c\u0026#34;, ans[i], \u0026#34; \\n\u0026#34;[i == q]); return 0; } ","date":"2024-10-25T01:08:21+08:00","image":"https://rafakang.github.io/p/codeforces-round-981-a~g/background_hu267459029147378459.png","permalink":"https://rafakang.github.io/p/codeforces-round-981-a~g/","title":"Codeforces Round 981 A~G"},{"content":"CF2020A 题目链接\n题意 一次操作可以从$n$减掉$k$的幂次，问最少操作数使得$n=0$。\n解法 把$N$变成$k$进制，然后输出各位的和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int Main() { int n, k; read(n, k); if (k == 1) return printf(\u0026#34;%d\\n\u0026#34;, n), 0; int ans = 0; while (n) { ans += n % k; n /= k; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } CF2020B 题目链接\n题意 假设有$n$个灯，一开始是亮的。从1开始枚举$i$，每次操作$i$的倍数的灯（亮变暗，暗变亮），最终有$k$个灯是亮的。求最小的$n$能达成恰好$k$个灯亮着\n解法 最终变暗的灯，一定是有奇数个约数。\n把一个数$x$分解质因数得到$x=\\prod p_i^{e_i}$，那么$d(x)=\\sum(e_i+1)$。\n如果$d(x)$是奇数，等价于$e_i$都是偶数。这样显然$x$是完全平方数。\n于是$N$以内能亮的灯就是$N-\\sqrt N$个，这是个单调的函数，因此可以二分得到$N$。\n注意整数开方的精度。WA了一发TNND。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int Main() { ll k; read(k); ll l = 1, r = k * 2; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; if (mid - (ll)sqrtl(mid) \u0026lt; k) l = mid + 1; else r = mid - 1; } std::cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; std::endl; return 0; } CF2020C 题目链接\n题意 给出$b,c,d$，问是否存在$a$使得$(a|b) - (a \\\u0026amp; c) = d$\n解法 如果$a$中有一个位置是1，那么$a|b$这一位必然是1，$a\\\u0026amp;c$这一位可能是1也可能是0。\n如果$a$中有一个位置是0，那么$a|b$这一位可能是0也可能是1，但是$a\\\u0026amp;c$必然是0。\n于是不存在一个位使得在这个位上$(a|b)\u0026lt;(a\\\u0026amp;c)$，那么做差等价于做异或。\n这样减法变成了各位独立的二进制异或操作，可以枚举$a$每一位的值判定结果是否等于$d$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int Main() { ll b, c, d; read(b, c, d); ll a = 0; for (int i = 0; i \u0026lt; 61; ++i) { int dbit = (d \u0026gt;\u0026gt; i) \u0026amp; 1; int cbit = (c \u0026gt;\u0026gt; i) \u0026amp; 1; int bbit = (b \u0026gt;\u0026gt; i) \u0026amp; 1; bool found = false; for (int abit = 0; abit \u0026lt; 2; ++abit) { if ((abit | bbit) ^ (cbit \u0026amp; abit) == dbit) { a |= ((ll)abit \u0026lt;\u0026lt; i); found = true; } } if (!found) return printf(\u0026#34;-1\\n\u0026#34;), 0; } std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; return 0; } CF2020D 题目链接\n题意 有$n$个点，$m$个操作。\n每个操作给出三个数$a,k,d$，连接$a+d, a+2d, a+3d, \u0026hellip;, a+kd$。\n问最终一共多少个连通块\n解法 一开始被迷惑了然后上了个厕所。\n上的时候发现，最终的图里面，每个点不重复的边最多就10条。那么可以考虑对于每个点$u$，维护一个长为10的数组$e$，$e[i]$如果不为0，可以认为$i$向$i+d$有边相连。\n那么原来的加边操作，相当于在$+d$的域上做了一个区间加，用差分维护一下即可。\n最终边数不超过$10n$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 struct DSU { public: DSU() : n(0) {} explicit DSU(int _n) : n(_n), parent_or_size(_n + 1, -1) {} int merge(int a, int b) { int x = leader(a), y = leader(b); if (x == y) return x; if (-parent_or_size[x] \u0026lt; -parent_or_size[y]) std::swap(x, y); parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x; return x; } bool same(int a, int b) { return leader(a) == leader(b); } int leader(int a) { if (parent_or_size[a] \u0026lt; 0) return a; return parent_or_size[a] = leader(parent_or_size[a]); } int size(int a) { return -parent_or_size[leader(a)]; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; groups() { std::vector\u0026lt;int\u0026gt; leader_buf(n + 1), group_size(n + 1); for (int i = 1; i \u0026lt;= n; i++) { leader_buf[i] = leader(i); group_size[leader_buf[i]]++; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result(n); for (int i = 1; i \u0026lt;= n; i++) { result[i].reserve(group_size[i]); } for (int i = 1; i \u0026lt;= n; i++) { result[leader_buf[i]].push_back(i); } result.erase( std::remove_if(result.begin(), result.end(), [\u0026amp;](const std::vector\u0026lt;int\u0026gt; \u0026amp;v) { return v.empty(); }), result.end()); return result; } private: int n; // root node: -1 * component size // otherwise: parent std::vector\u0026lt;int\u0026gt; parent_or_size; }; int Main() { int n, m; read(n, m); std::vector\u0026lt;std::array\u0026lt;int, 11\u0026gt;\u0026gt; tag(n + 1); DSU dsu(n); for (int i = 1; i \u0026lt;= m; ++i) { int a, d, k; read(a, d, k); tag[a][d] += 1; tag[a + k * d][d] -= 1; } for (int i = 1; i \u0026lt;= n; ++i) { for (int d = 1; d \u0026lt;= 10; ++d) { if (i - d \u0026gt;= 1) tag[i][d] += tag[i - d][d]; if (tag[i][d] \u0026gt; 0 \u0026amp;\u0026amp; i + d \u0026lt;= n) dsu.merge(i, i + d); } } int ans = 0; for (int i = 1; i \u0026lt;= n; ++i) ans += dsu.leader(i) == i; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } CF2020E 题目链接\n题意 有$n$个数$a[i]$，每个数被选中的概率是$p[i]$。 把这些数按概率扔到一个多重集合$S$里。设$f(S)$是集合的异或和，求$E(f(S)^2)$\n解法 由于平方不是一个线性变换，那么集合的异或平方值的期望不能等于集合异或期望值的平方。\n所以单独考虑集合异或值在平方之后的式子。\n一个二进制数可以考虑为各个1的加和。那么平方之后就是各个位的平方和+2倍每两位的乘积和。\n和的形式可以利用期望线性性处理，因此考虑对求各位平方的期望以及每两位乘积的期望。\n由期望公式，收益是一定的，因此这等价于求一个概率。\n某一位$k$为1，等价于集合中的数，$k$位为1的个数是奇数。而每个数可选可不选，这似乎是一个背包。\n对于固定的一位$k$，用$dp[i][j]$表示前$i$个数，奇偶性为$j$时的概率，背包转移一下即可。\n每两位乘积的期望就是依次考虑两个位，用一个长为2的二进制串分别表示这两位的奇偶性，同样是一个背包。\n最后根据期望公式加和一下就ok。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); std::vector\u0026lt;modint\u0026gt; prob(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); modint inv = modint(10000).inv(); for (int i = 1; i \u0026lt;= n; ++i) { int v; read(v); prob[i] = v * inv; } std::vector\u0026lt;std::array\u0026lt;modint, 2\u0026gt;\u0026gt; dp1(n + 1); modint ans = 0; for (int p = 0; p \u0026lt; 10; ++p) { dp1.assign(n + 1, {}); dp1[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] \u0026gt;\u0026gt; p \u0026amp; 1) { dp1[i][0] = dp1[i - 1][0] * (1 - prob[i]) + dp1[i - 1][1] * prob[i]; dp1[i][1] = dp1[i - 1][1] * (1 - prob[i]) + dp1[i - 1][0] * prob[i]; } else dp1[i] = dp1[i - 1]; } // printf(\u0026#34;p = %d, dp = %d\\n\u0026#34;, p, dp1[n][1]); ans += (1 \u0026lt;\u0026lt; (p + p)) * dp1[n][1]; } std::vector\u0026lt;std::array\u0026lt;modint, 4\u0026gt;\u0026gt; dp2(n + 1); for (int p = 0; p \u0026lt; 10; ++p) for (int q = p + 1; q \u0026lt; 10; ++q) { dp2.assign(n + 1, {}); dp2[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { int mask = 0; if (a[i] \u0026gt;\u0026gt; p \u0026amp; 1) mask |= 2; if (a[i] \u0026gt;\u0026gt; q \u0026amp; 1) mask |= 1; for (int pmask = 0; pmask \u0026lt; 4; ++pmask) { dp2[i][pmask] += dp2[i - 1][pmask] * (1 - prob[i]); dp2[i][pmask ^ mask] += dp2[i - 1][pmask] * prob[i]; } } ans += 2 * (1 \u0026lt;\u0026lt; p) * (1 \u0026lt;\u0026lt; q) * dp2[n][3]; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } CF2020F 题目链接\n题意 假设有一棵树，根节点的点权是$x$。\n第$i$层的点，把点权的约数作为新点的点权扩展到自己的子节点；假设一共做$d$次，最终的叶子节点是$f(x,d)$。\n给出一个$n\\leq 10^9$，求$\\sum_{i=1}^n f(i^k, d)$ $k,d\\leq 10^5$\n解法 大概看了一下数据规模和给出函数形式，由于跟约数个数函数相关，感觉是积性函数求和问题。\n可以打个表验证一下对于固定的$k$和$d$，这个函数是不是积性函数。\n经过打表可以确定这是积性函数。那么积性函数求和问题，先考虑min25筛，因为$d=1$的情况是典题，可以用min25筛来做。\n其实这个地方我是先看到$d=1$是min25筛，接下来走偏了，考虑从$d$去推$d+1$的做法。VP的时候懒了没去打表，实际上应该先打个表。\n对于质数$p$，$f(p^k,d)$的形式应该是每层都是$p^e$。每一步可以考虑直接落到最后下一步，或者考虑降幂落到下一步。\n设$d$个变量，$x[i]$表示在第$i$步的降幂，那么显然$x[i]\\geq 0$，且$\\sum_{i=1}^d x[i]\\leq k$。\n这个不等式解的数量就是$f(p^k, d)$。\n$\\sum_{i=1}^d x[i]\\leq k$等价于$\\sum_{i=1}^d x[i] = k - t(t\\geq 0)$。\n$$\\sum_{i=1}^{d+1} x[i]=k(x[i]\\geq 0)$$求这个方程解的数量显然隔板法得到$C(k+d,d)$。\n那么质数部分就是一个常量，显然是完全积性函数，满足min25筛。\n考虑质数的指数部分，$f(p^{tk}, d)=C(kt+d,d)$，可以$O(1)$得到，也满足min25筛。\n于是套一个min25筛就行了。\n注意组合数可能会取到几百万。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 template \u0026lt;int m, std::enable_if_t\u0026lt;(1 \u0026lt;= m)\u0026gt; * = nullptr\u0026gt; struct static_modint { using mint = static_modint; public: static constexpr int mod() { return m; } static mint raw(int v) { mint x; x._v = v; return x; } static_modint() : _v(0) {} static_modint(long long v) { long long x = (long long)(v % (long long)(umod())); if (x \u0026lt; 0) x += umod(); _v = (unsigned int)(x); } static_modint(int v) { _v = (unsigned int)(v % umod()); } unsigned int val() const { return _v; } mint \u0026amp;operator++() { _v++; if (_v == umod()) _v = 0; return *this; } mint \u0026amp;operator--() { if (_v == 0) _v = umod(); _v--; return *this; } mint operator++(int) { mint result = *this; ++*this; return result; } mint operator--(int) { mint result = *this; --*this; return result; } mint \u0026amp;operator+=(const mint \u0026amp;rhs) { _v += rhs._v; if (_v \u0026gt;= umod()) _v -= umod(); return *this; } mint \u0026amp;operator-=(const mint \u0026amp;rhs) { _v -= rhs._v; if (_v \u0026gt;= umod()) _v += umod(); return *this; } mint \u0026amp;operator*=(const mint \u0026amp;rhs) { unsigned long long z = _v; z *= rhs._v; _v = (unsigned int)(z % umod()); return *this; } mint \u0026amp;operator/=(const mint \u0026amp;rhs) { return *this = *this * rhs.inv(); } mint operator+() const { return *this; } mint operator-() const { return mint() - *this; } mint pow(long long n) const { assert(0 \u0026lt;= n); mint x = *this, r = 1; while (n) { if (n \u0026amp; 1) r *= x; x *= x; n \u0026gt;\u0026gt;= 1; } return r; } mint inv() const { assert(_v); return pow(umod() - 2); } friend mint operator+(const mint \u0026amp;lhs, const mint \u0026amp;rhs) { return mint(lhs) += rhs; } friend mint operator-(const mint \u0026amp;lhs, const mint \u0026amp;rhs) { return mint(lhs) -= rhs; } friend mint operator*(const mint \u0026amp;lhs, const mint \u0026amp;rhs) { return mint(lhs) *= rhs; } friend mint operator/(const mint \u0026amp;lhs, const mint \u0026amp;rhs) { return mint(lhs) /= rhs; } friend bool operator==(const mint \u0026amp;lhs, const mint \u0026amp;rhs) { return lhs._v == rhs._v; } friend bool operator!=(const mint \u0026amp;lhs, const mint \u0026amp;rhs) { return lhs._v != rhs._v; } private: unsigned int _v; static constexpr unsigned int umod() { return m; } // static constexpr bool prime = internal::is_prime\u0026lt;m\u0026gt;; }; template \u0026lt;class T\u0026gt; struct Combinatorics { int n = 0; std::vector\u0026lt;T\u0026gt; fac; std::vector\u0026lt;T\u0026gt; invfac; std::vector\u0026lt;T\u0026gt; inv; Combinatorics(int _n = 0) : fac{1}, invfac{1}, inv{0} { init(_n); } void init(int m) { if (n \u0026gt;= m) return; fac.resize(m + 1), invfac.resize(m + 1), inv.resize(m + 1); for (int i = n + 1; i \u0026lt;= m; ++i) fac[i] = fac[i - 1] * i; invfac[m] = fac[m].inv(); for (int i = m; i \u0026gt; n + 1; --i) invfac[i - 1] = invfac[i] * i; for (int i = m; i \u0026gt; n; --i) inv[i] = invfac[i] * fac[i - 1]; n = m; } T operator()(int x, int y) { if (x \u0026lt; y) return 0; return fac[x] * invfac[y] * invfac[x - y]; } }; using modint = static_modint\u0026lt;(int)1e9 + 7\u0026gt;; auto sieve(int mx) { std::vector minp(mx + 1, 0); std::vector\u0026lt;int\u0026gt; prime; for (int i = 2; i \u0026lt;= mx; ++i) { if (minp[i] == 0) prime.push_back(i), minp[i] = i; for (int p : prime) { if (1ll * i * p \u0026gt; mx) break; minp[i * p] = p; if (i % p == 0) break; } } return prime; } int Main() { static Combinatorics\u0026lt;modint\u0026gt; combinatorics(4e6 + 5); ll n, k, d; read(n, k, d); const int sqrtn = std::sqrt(n); auto prime = sieve(sqrtn); std::vector\u0026lt;ll\u0026gt; v; for (ll l = 1, r = 1; l \u0026lt;= n; l = r + 1) { v.push_back(n / l); r = n / (n / l); } auto idx = [\u0026amp;](ll x) -\u0026gt; int { if (x \u0026lt;= sqrtn) return v.size() - x; else return n / x - 1; }; std::vector\u0026lt;modint\u0026gt; sp(v.size()); for (int i = 0; i \u0026lt; v.size(); ++i) { int x = v[i]; sp[i] = x - 1; } std::vector\u0026lt;modint\u0026gt; sum(prime.size() + 1); for (int i = 1; i \u0026lt;= prime.size(); ++i) { int p = prime[i - 1]; for (int n = 0; n \u0026lt; v.size(); ++n) { ll x = v[n]; if (x \u0026lt; 1ll * p * p) break; sp[n] -= (sp[idx(x / p)] - sum[i - 1]); } sum[i] = sum[i - 1] + 1; } for (int i = 0; i \u0026lt; v.size(); ++i) sp[i] *= combinatorics(k + d, d); for (int i = 1; i \u0026lt;= prime.size(); ++i) sum[i] *= combinatorics(k + d, d); std::vector\u0026lt;modint\u0026gt; sc(v.size()); for (int i = prime.size(); i \u0026gt;= 1; --i) { int p = prime[i - 1]; for (int n = 0; n \u0026lt; v.size(); ++n) { ll x = v[n]; if (1ll * p * p \u0026gt; x) break; ll pw = p; for (int e = 1; x / pw \u0026gt;= p; ++e) { modint f = combinatorics(e * k + d, d); int j = idx(x / pw); sc[n] += f * (sc[j] + sp[j] - sum[i]); pw *= p; if (pw \u0026lt;= x) sc[n] += combinatorics((e + 1) * k + d, d); } } } modint ans = sp[0] + sc[0] + 1; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2024-10-23T22:55:04+08:00","image":"https://rafakang.github.io/p/vpcodeforces-round-976-a~f/background_hu267459029147378459.png","permalink":"https://rafakang.github.io/p/vpcodeforces-round-976-a~f/","title":"[VP]Codeforces Round 976 A~F"},{"content":"Atcoder泛做 ARC178D.Delete Range Mex 一个长度为$N$的排列$P$，每次选一个区间，然后把区间$Mex$从这个排列中移除。问有多少排列$P$能通过以上操作最终得到一个长度为$M$的序列$A$\n$M\\leq N\\leq500$\n计数题，应该先找计数对象的特征。\n首先拿$A$序列和$[1,N]$做一个差，就能得到每次移除的$Mex$。这些$Mex$一定从大到小移除的。因为如果反之，当我取更大$Mex$的时候会发现少了一个数而取不到。\n选择一个原序列中的区间然后删除Mex的话，首先这个Mex一定不在区间中，并且$[0, Mex-1]$中的所有数都一定出现在这个区间里。那么假设$[0,Mex-1]$这些数在原序列中的区间是$[l,r]$，那么$Mex$一定在$[l,r]$的外面。\n接下来是对于我来说比较容易忽略的点——每次移除操作不改变元素的相对位置，这样$A$序列就是原序列的一个子序列。\n那么计数对象$P$的特征大概就是\n$A$是$P$的子序列 一个$Mex$必然在$[0,Mex-1]$形成的区间之外 考虑到$Mex$的位置由$[0,Mex-1]$确定，那么从小到大向序列中加数。\n因为性质1，所有这里加数只能在$A$序列的空隙中加，一共有$M+1$个空位。\n考虑性质2，当添加一个新数$i$的时候，我们还需要知道$[0,i-1]$的区间是多大，这样才能确定$i$的可选位置。\n所以可以写出如下DP。\n$dp[i][l][r]$表示前$i$个数，目前占据了$[l,r]$这些空位的序列方案数。当$i$是一个$Mex$的时候，考虑枚举$i$的位置，$i$可选的位置大概是$l$之前包括$l$，$r$之后包括$r$的所有空位。当$i$不是一个$Mex$的时候，最开始就卡在这里，实际上假设$i$的位置是$pos[i]$，那么枚举前$i-1$的空位$[l,r]$，跟当前$pos[i]$做一个并即可。\n具体实现上DP的状态发生了一些变化。\n$dp[i][l][r]$表示如果下一个$Mex$是$i$，当前$[l,r]$不可用的方案数。最终输出的结果是$dp[N][2][M]$，因为最左边和最右边的空位永远都可以用，且整个序列的$Mex$是$N$。由性质2，在$i$空位插入一个数，相当于屏蔽了$i-1$空位或$i+1$空位；如果是$A$序列中的$i$位置，相当于屏蔽了$i$空位或$i+1$空位。转移大差不差。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 int Main() { int N, M; read(N, M); std::vector\u0026lt;int\u0026gt; a(M + 1); for (int i = 1; i \u0026lt;= M; ++i) read(a[i]); std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;modint\u0026gt;\u0026gt;\u0026gt; dp(N + 1, std::vector(M + 3, std::vector\u0026lt;modint\u0026gt;(M + 3))); std::vector\u0026lt;int\u0026gt; pos(N, 0); for (int i = 1; i \u0026lt;= M; ++i) pos[a[i]] = i; if (!pos[0]) { for (int i = 1; i \u0026lt;= M + 1; ++i) dp[1][i + 1][i - 1] = 1; } else dp[1][pos[0] + 1][pos[0]] = 1; for (int i = 1; i \u0026lt; N; ++i) { if (!pos[i]) { for (int l = 2; l \u0026lt;= M + 2; ++l) { modint sum = 0; for (int j = 1; j \u0026lt;= M + 1; ++j) { dp[i + 1][l][j - 1] += sum + dp[i][l][j - 1]; sum += dp[i][l][j - 1]; } } for (int r = 0; r \u0026lt;= M; ++r) { modint sum = 0; for (int j = M + 1; j \u0026gt;= 1; --j) { dp[i + 1][j + 1][r] += sum + dp[i][j + 1][r]; sum += dp[i][j + 1][r]; } } } else { for (int l = 2; l \u0026lt;= M + 2; ++l) for (int r = 0; r \u0026lt;= M; ++r) dp[i + 1][std::min(pos[i] + 1, l)][std::max(pos[i], r)] += dp[i][l][r]; } // for (int l = 2; l \u0026lt;= M + 2; ++l) // for (int r = 0; r \u0026lt;= M; ++r) // printf(\u0026#34;dp[%d][%d][%d] = %d\\n\u0026#34;, i + 1, l, r, dp[i + 1][l][r]); } printf(\u0026#34;%d\\n\u0026#34;, dp[N][2][M]); return 0; } 总结一下：方向是对的，先根据题意找计数对象的特征。而且基本上分析差不多了，但是卡在枚举到$A$序列本身那个地方。实现的时候，这种维数比较多的转移写起来要非常非常小心且专心，每个决策对应的转移都要想得非常清楚，debug的时候要有耐心，手算即便很困难也不能弃疗。\nABC349G.Max (Sum - Max) 有两个长度为$N$的序列$A$和$B$。给出一个长度$k$，选出$k$个下标组成集合$S$，求$\\sum_{i \\in S}A[i] - max_{i \\in S}B[i]$。对于每个$k$，求这样的值\n假设就一个$k$，按$B$排序，显然就是一个经典数据结构问题。选一个最好的$i$，使得$A[i-1]$之前的前$k-1$大+$A[i]-B[i]$最大。\n但是现在很多个$k$，就得琢磨一下了。\n一般来说这种都会有一个性质，比如单调性。对于某一个$k$，最好的是$i$。那么对于$k+1$，决策点不会小于$i$。\n可以打表也可以证一下。\n设$F_{i}(k)$表示前$i$个数前$k$大的和。对于$j \u0026lt; i$，有$F_{j-1}(k-1)+A[j]-B[j] \u0026lt; F_{i-1}(k-1)+A[i]-B[i]$\n如果对于$k+1$，决策点是$j$，那么$F_{j}(k)+A[j]-B[j]\u0026gt;F_{i}(k)+A[i]-B[i]$。设$a_{i}[k]$表示前$i$个数第$k$大的数。那么$F_{j-1}(k-1)+a_{j}[k]+A[j]-B[j]\u0026gt;F_{i}(k)+a_{i}[k]+A[i]-B[i]$。由于$i\u0026gt;j$那么显然$a_{j}[k] \\leq a_{i}[k]$，所以就矛盾了。那么可以知道决策一定是单调的。\n利用类似DP单调性优化二分队列的思想，用一个栈维护决策以及对应区间，最终求解即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma GCC optimize(\u0026#34;inline\u0026#34;, \u0026#34;fast-math\u0026#34;, \u0026#34;unroll-loops\u0026#34;, \u0026#34;no-stack-protector\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; using ll = long long; using uint = unsigned int; using ull = unsigned long long; #define lowbit(x) (x \u0026amp; (-x)) const int mod = 998244353; const double PI = 3.14159265358; std::mt19937 rng(std::random_device{}()); namespace FI { char B[1 \u0026lt;\u0026lt; 16], *S = B, *T = B; inline char getc() { return S == T \u0026amp;\u0026amp; (T = (S = B) + fread(B, 1, 1 \u0026lt;\u0026lt; 16, stdin), S == T) ? EOF : *S++; } inline void read() { } template \u0026lt;typename Tp, typename... Types\u0026gt; inline void read(Tp \u0026amp;o, Types \u0026amp;...Args) { o = 0; bool s = 0; char c = getc(); while (c \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) s |= c == \u0026#39;-\u0026#39;, c = getc(); while (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) o = o * 10 + c - \u0026#39;0\u0026#39;, c = getc(); if (s) o = -o; read(Args...); } } // namespace FI using FI::read; constexpr int MultiTestCases = 0; constexpr int MAXN = 2e5; struct Info { int v; ll sum = 0; int size = 0; }; struct Merge { Info operator()(const Info \u0026amp;lhs, const Info \u0026amp;rhs) const { Info res; res.sum = lhs.sum + rhs.sum; res.size = lhs.size + rhs.size; res.v = rhs.v; return res; } }; struct PersistentSegmentTree { const int n; const Merge merge; struct node { std::array\u0026lt;int, 2\u0026gt; ch{}; Info info; }; std::array\u0026lt;node, MAXN * 20 + 5\u0026gt; tree; int cnt = 0; PersistentSegmentTree(int _n) : n(_n), merge(Merge()) { } void pull(int p) { int ls = tree[p].ch[0], rs = tree[p].ch[1]; tree[p].info = merge(tree[ls].info, tree[rs].info); } int modify(int p, int l, int r, int x, const Info \u0026amp;v) { int q = ++cnt; tree[q] = tree[p]; if (l == r) return tree[q].info = merge(tree[p].info, v), q; auto [ls, rs] = tree[p].ch; int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) tree[q].ch[0] = modify(ls, l, mid, x, v); else tree[q].ch[1] = modify(rs, mid + 1, r, x, v); return pull(q), q; } int modify(int root, int p, const Info \u0026amp;v) { return modify(root, 1, n, p, v); } Info query(int p, int l, int r, int x, int y) { if (p == 0) return Info{}; if (l == x \u0026amp;\u0026amp; r == y) return tree[p].info; int mid = (l + r) \u0026gt;\u0026gt; 1; auto [ls, rs] = tree[p].ch; if (y \u0026lt;= mid) return query(ls, l, mid, x, y); else if (x \u0026gt; mid) return query(rs, mid + 1, r, x, y); else return merge(query(ls, l, mid, x, mid), query(rs, mid + 1, r, mid + 1, y)); } Info query(int root, int l, int r) { if (l \u0026gt; r) return Info{}; return query(root, 1, n, l, r); } Info right_most(int p, int l, int r, int k) { if (k == 0) return {}; if (l == r) return {tree[p].info.v, 1ll * tree[p].info.v * k, k}; auto mid = (l + r) \u0026gt;\u0026gt; 1; auto [ls, rs] = tree[p].ch; if (tree[rs].info.size \u0026lt;= k) return merge(right_most(ls, l, mid, k - tree[rs].info.size), tree[rs].info); else return right_most(rs, mid + 1, r, k); } Info right_most(int root, int k) { return right_most(root, 1, n, k); } }; std::pair\u0026lt;int, ll\u0026gt; A[MAXN + 5]; int roots[MAXN + 5]; struct Node { int i, l, r; }; Node stack[MAXN + 5]; ll ans[MAXN + 5]; int Main() { int N; read(N); for (int i = 1; i \u0026lt;= N; ++i) read(A[i].first, A[i].second); std::sort(A + 1, A + N + 1, [\u0026amp;](const std::pair\u0026lt;int, ll\u0026gt; \u0026amp;lhs, const std::pair\u0026lt;int, ll\u0026gt; \u0026amp;rhs) { return lhs.second \u0026lt; rhs.second; }); std::set\u0026lt;int\u0026gt; set; std::map\u0026lt;int, int\u0026gt; mp; for (int i = 1; i \u0026lt;= N; ++i) set.insert(A[i].first); int cnt = 0; for (int v : set) mp[v] = ++cnt; static PersistentSegmentTree segment_tree(cnt); for (int i = 1; i \u0026lt;= N; ++i) roots[i] = segment_tree.modify(roots[i - 1], mp[A[i].first], {A[i].first, A[i].first, 1}); auto cmp = [\u0026amp;](int j, int i, int k) -\u0026gt; bool { ll left = segment_tree.right_most(roots[j - 1], k - 1).sum + A[j].first - A[j].second; ll right = segment_tree.right_most(roots[i - 1], k - 1).sum + A[i].first - A[i].second; return left \u0026gt; right; }; int top = 0; for (int i = 1; i \u0026lt;= N; ++i) { while (top \u0026amp;\u0026amp; !cmp(stack[top].i, i, stack[top].l)) top--; if (top) { auto [j, l, r] = stack[top]; while (l \u0026lt;= r) { auto mid = (l + r) \u0026gt;\u0026gt; 1; if (cmp(j, i, mid)) l = mid + 1; else r = mid - 1; } stack[top].r = r; stack[++top] = {i, l, i}; } else stack[++top] = {i, 1, i}; } while (top) { auto [i, l, r] = stack[top]; top--; for (int k = l; k \u0026lt;= r; ++k) { Info res = segment_tree.right_most(roots[i - 1], k - 1); ans[k] = res.sum + A[i].first - A[i].second; } } for (int i = 1; i \u0026lt;= N; ++i) printf(\u0026#34;%lld\\n\u0026#34;, ans[i]); return 0; } int main() { int TestCases = 1; if constexpr (MultiTestCases == 1) scanf(\u0026#34;%d\u0026#34;, \u0026amp;TestCases); while (TestCases--) Main(); return 0; } 由于求解的内容没有前后依赖，可以使用更好写的决策单调性分治；并且由于决策点暴力转移时间复杂度不会更高的特性，可以避免使用可持久化线段树这样常数大的数据结构，实测下来真的差好多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 #pragma GCC optimize(\u0026#34;Ofast\u0026#34;) #pragma GCC optimize(\u0026#34;inline\u0026#34;, \u0026#34;fast-math\u0026#34;, \u0026#34;unroll-loops\u0026#34;, \u0026#34;no-stack-protector\u0026#34;) #include \u0026lt;bits/stdc++.h\u0026gt; using ll = long long; using uint = unsigned int; using ull = unsigned long long; #define lowbit(x) (x \u0026amp; (-x)) const int mod = 998244353; const double PI = 3.14159265358; std::mt19937 rng(std::random_device{}()); namespace FI { char B[1 \u0026lt;\u0026lt; 16], *S = B, *T = B; inline char getc() { return S == T \u0026amp;\u0026amp; (T = (S = B) + fread(B, 1, 1 \u0026lt;\u0026lt; 16, stdin), S == T) ? EOF : *S++; } inline void read() { } template \u0026lt;typename Tp, typename... Types\u0026gt; inline void read(Tp \u0026amp;o, Types \u0026amp;...Args) { o = 0; bool s = 0; char c = getc(); while (c \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) s |= c == \u0026#39;-\u0026#39;, c = getc(); while (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) o = o * 10 + c - \u0026#39;0\u0026#39;, c = getc(); if (s) o = -o; read(Args...); } } // namespace FI using FI::read; constexpr int MultiTestCases = 0; template \u0026lt;class T, typename Merge = std::plus\u0026lt;T\u0026gt;\u0026gt; struct FenwickTree { std::vector\u0026lt;T\u0026gt; fwt; const Merge merge{}; int n; #ifndef lowbit inline int lowbit(int x) const { return (x \u0026amp; (-x)); } #endif FenwickTree(int _n) : n(_n), fwt(_n + 1) { } void modify(int pos, T delta) { if (pos == 0) return fwt[0] = merge(fwt[0], delta), void(); for (int i = pos; i \u0026lt;= n; i += lowbit(i)) fwt[i] = merge(fwt[i], delta); } T query(int pos) const { T res{}; if (pos \u0026lt; 0) return res; pos = std::min(pos, n); for (int i = pos; i; i -= lowbit(i)) res = merge(res, fwt[i]); res = merge(res, fwt[0]); return res; } }; struct Info { ll sum = 0; int size = 0; }; Info operator+(const Info \u0026amp;lhs, const Info \u0026amp;rhs) { return {lhs.sum + rhs.sum, lhs.size + rhs.size}; } int Main() { int n; read(n); std::vector\u0026lt;std::pair\u0026lt;ll, int\u0026gt;\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i].second, a[i].first); std::sort(a.begin() + 1, a.end()); std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; tab(n + 1); for (int i = 1; i \u0026lt;= n; ++i) tab[i] = {a[i].second, i}; std::sort(tab.begin() + 1, tab.end(), std::greater\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;{}); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= n; ++i) p[tab[i].second] = i; FenwickTree\u0026lt;Info\u0026gt; fwt(n); static constexpr ll INF = 1e18; int cur = 0; auto f = [\u0026amp;](int i, int k) { if (i \u0026lt; k) return -INF; while (cur \u0026lt; i) { cur++; fwt.modify(p[cur], {a[cur].second, 1}); } while (cur \u0026gt; i) { fwt.modify(p[cur], {-a[cur].second, -1}); cur--; } int l = 1, r = n; fwt.modify(p[i], {-a[i].second, -1}); while (l \u0026lt;= r) { auto mid = (l + r) \u0026gt;\u0026gt; 1; auto [_, size] = fwt.query(mid); if (size \u0026gt; k - 1) r = mid - 1; else l = mid + 1; } ll res = fwt.query(r).sum + a[i].second - a[i].first; fwt.modify(p[i], {a[i].second, 1}); return res; }; std::vector\u0026lt;ll\u0026gt; ans(n + 1); std::vector\u0026lt;int\u0026gt; cnt(n + 1); std::function\u0026lt;void(int, int, int, int)\u0026gt; solve = [\u0026amp;](int l, int r, int dl, int dr) { int mid = (l + r) \u0026gt;\u0026gt; 1, best = dl; ll mx = -INF; for (int i = dl; i \u0026lt;= dr; ++i) { if (ll tmp = f(i, mid); tmp \u0026gt; mx) mx = tmp, best = i; } // printf(\u0026#34;%d %d\\n\u0026#34;, mid, best); ans[mid] = mx; for (int i = dl; i \u0026lt;= dr; ++i) if (cnt[p[i]]) fwt.modify(p[i], {-a[i].second, -1}), cnt[p[i]]--; if (l \u0026lt; mid) solve(l, mid - 1, dl, best); if (r \u0026gt; mid) solve(mid + 1, r, best, dr); }; solve(1, n, 1, n); for (int i = 1; i \u0026lt;= n; ++i) printf(\u0026#34;%lld\\n\u0026#34;, ans[i]); return 0; } int main() { int TestCases = 1; if constexpr (MultiTestCases == 1) scanf(\u0026#34;%d\u0026#34;, \u0026amp;TestCases); while (TestCases--) Main(); return 0; } 总结一下：对于单个$k$，是典题；如果是多个$k$需要考虑特殊性质，一般来说都是一些单调性；在这道题里能隐隐约约感觉到这个单调性的存在，如果不想证明就直接打表；在有限的时间内（ABC只有100分钟）凭直觉猜结论这种能力还是很重要的。\n决策单调性，二分队列是很常规的做法，基本上可以应对绝大部分的情况，然而一般来说这种算法的常数都比较大。在这里的体现是，比较两个决策点的优劣时旧决策点维护的数据结构要保留，所以只能使用可持久化数据结构，空间和时间常数都很大。\n单调性分治的做法是对于$[l,r]$直接暴力求一个$mid$，得到子区间的决策上下界，再求$[l,mid-1]$和$[mid+1,r]$。如果是这种$dp[i] = dp[j]+w(j,i)$的式子，在$dp[l..mid-1]$求解之前无法确定$dp[mid]$的值，单调性分治就会失效，所以经常见于分层的动态规划。\nABC326G.Unlock Achievement $N$个技能，$M$个成就。技能升级需要花费，最高升五级。一个成就需要某些技能达到某些等级，获得某些回报。求最大的回报-花费是多少\n一句话：最大权闭合子图\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;atcoder/maxflow\u0026gt; int Main() { int n, m; read(n, m); std::vector\u0026lt;int\u0026gt; c(n + 1), a(m + 1); for (int i = 1; i \u0026lt;= n; ++i) read(c[i]); for (int i = 1; i \u0026lt;= m; ++i) read(a[i]); int sum = std::accumulate(a.begin(), a.end(), 0); std::vector l(m + 1, std::vector\u0026lt;int\u0026gt;(n + 1)); for (int i = 1; i \u0026lt;= m; ++i) for (int j = 1; j \u0026lt;= n; ++j) read(l[i][j]); atcoder::mf_graph\u0026lt;int\u0026gt; graph(m + n * 5 + 2); int s = 0, t = m + n * 5 + 1; for (int i = 1; i \u0026lt;= n; ++i) { for (int k = 2; k \u0026lt;= 5; ++k) graph.add_edge(m + (i - 1) * 5 + k, t, c[i]); for (int k = 2; k \u0026lt;= 5; ++k) graph.add_edge(m + (i - 1) * 5 + k, m + (i - 1) * 5 + k - 1, std::numeric_limits\u0026lt;int\u0026gt;::max()); } for (int i = 1; i \u0026lt;= m; ++i) { graph.add_edge(s, i, a[i]); for (int j = 1; j \u0026lt;= n; ++j) graph.add_edge(i, m + (j - 1) * 5 + l[i][j], std::numeric_limits\u0026lt;int\u0026gt;::max()); } auto cut = graph.flow(s, t); std::cout \u0026lt;\u0026lt; sum - cut \u0026lt;\u0026lt; std::endl; return 0; } 总结一下：读题就建出模了，很典\u0026hellip;\nABC335G.Discrete Logarithm Problems 给出一个数组$A$和质数$P$，找出数对$(i,j)$满足：存在$k$使得$A_{i}^k \\equiv A_{j} \\bmod P$。$N\\leq 2 \\times 10^5, P\\leq 10^{13}$\n题目明示离散对数问题，考虑原根。一个奇素数必然存在原根，这个原根是模$P$运算的生成元，设这个原根是$g$，那么对于$[1,P-1]$中每个数，都是$g$的某次幂，且$g,g^2,\u0026hellip;,g^{P-1}$是不同的数。\n接下来考虑阶的定义。一个数$a=g^q$的阶$m$，指的是最小的$m$使得$a^m \\equiv 1\\bmod P$。注意到$g^{q * m} \\equiv 1 \\bmod P$，$m$是$a$的阶。那么$q * m$是$P-1$的倍数，且$m$是最小的，这样$q*m$就是$lcm(q,P-1)$。于是$m=\\frac{gcd(P-1,q)}{d}$。\n引入原根之后，可以把$A_i$写成$g^{q_i}$。于是就变成$g^{q_i * k}\\equiv g^{q_j}\\bmod P$。由于幂运算肯定有一个长度为$P-1$的环，那么相当于$q_i * k\\equiv q_{j} \\bmod (P-1)$。这个方程有解的前提是$q_j$是$gcd(q_i, P-1)$的倍数。等价于$gcd(q_j, P-1)|gcd(q_i, P-1)$。设$d[i] = gcd(q_i, P-1)$，统计$d[i]|d[j]$的个数。\n由于$10^{13}$内的数最多有$11000$个左右的约数，所以暴力遍历是可行的，总次数大概是5e7的级别。\n问题变成怎么求$d[i]$。朴素的想法肯定是找到原根$g$，然后挨个求幂次。第一想法是BSGS，而实际上BSGS算法的复杂度太高会TLE。其实这里我们只想要$d[i]$。所以用找到$a[i]$的阶就能找到$d[i]$。\n所以问题变成了怎么求阶。$a^{P-1}\\equiv 1 \\bmod P$，然后$m$肯定是$P-1$的约数且是满足条件最小的那个。可以考虑把$P-1$质因数分解，一个一个质因数往下除，直到幂次不为1。一共有$O(log_{2}(P-1))$个质因数，每次求快速幂都有$O(log_{2}P)$的复杂度，因此总复杂度是$O(Nlog_{2}^2P)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 int Main() { int n; ll p; read(n, p); std::vector\u0026lt;ll\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); if (p == 2) { int z0 = 0, z1 = 0; for (int i = 1; i \u0026lt;= n; ++i) z0 += (a[i] % 2) == 0, z1 += (a[i] % 2); std::cout \u0026lt;\u0026lt; 1ll * z0 * z0 + 1ll * z1 * z1 \u0026lt;\u0026lt; std::endl; return 0; } std::vector\u0026lt;ll\u0026gt; order(n + 1); std::vector\u0026lt;int\u0026gt; prime; static constexpr int MX = 3.2e6; static std::array\u0026lt;int, MX\u0026gt; mnp{}; for (int i = 2; 1ll * i * i \u0026lt;= p; ++i) { if (!mnp[i]) mnp[i] = i, prime.push_back(i); for (int pr : prime) { if (1ll * pr * i * i * pr \u0026gt; p) break; mnp[i * pr] = pr; if (i % pr == 0) break; } } auto pow = [\u0026amp;](ll x, ll q) -\u0026gt; ll { if (q == 0) return 1; __uint128_t ans = 1, base = x; while (q) { if (q \u0026amp; 1) ans = ans * base % p; q \u0026gt;\u0026gt;= 1; base = base * base % p; } return ans % p; }; std::vector\u0026lt;std::pair\u0026lt;ll, int\u0026gt;\u0026gt; pfactors; ll q = p - 1; for (int pr : prime) { int size = 0; while (q % pr == 0) { size++; q /= pr; } if (size) pfactors.emplace_back(pr, size); } if (q != 1) pfactors.emplace_back(q, 1); for (int i = 1; i \u0026lt;= n; ++i) { order[i] = p - 1; for (auto [pr, size] : pfactors) { while (size--) { if (pow(a[i], order[i] / pr) == 1) order[i] /= pr; else break; } } } std::vector\u0026lt;ll\u0026gt; d(n + 1); for (int i = 1; i \u0026lt;= n; ++i) d[i] = (p - 1) / order[i]; std::map\u0026lt;ll, int\u0026gt; mp; for (int i = 1; i \u0026lt;= n; ++i) mp[d[i]]++; std::vector\u0026lt;std::pair\u0026lt;ll, int\u0026gt;\u0026gt; buc; for (auto [gcd, size] : mp) buc.emplace_back(gcd, size); ll ans = 0; for (int i = 0; i \u0026lt; buc.size(); ++i) { ans += 1ll * buc[i].second * buc[i].second; for (int j = i + 1; j \u0026lt; buc.size(); ++j) if (buc[j].first % buc[i].first == 0) ans += 1ll * buc[i].second * buc[j].second; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } 总结一下：涉及很多离散对数、原根和阶的基础知识和引理。从引入原根开始，思路是很自然的，前提是懂知识点，是一道很好的例题。ABC果然很Educational。感觉还应该记一下各数量级的超级合数的东西，快速推定约数个数的最大值，方便计算复杂度。 OEIS链接。 然后Codeforces的讨论中提到可以使用$O(N^{\\frac{1}{3}})$来估算。\nARC179D.Portable Gate 一棵$N$个节点的树，有一个棋子和传送门，任意节点开始遍历整棵树。有三种操作：\n沿一条边移动棋子，花费为1 将棋子移动到传送门处，没有花费 将传送门移动到棋子处，没有花费 问最少的遍历花费是多少\n$N \\leq 2 \\times 10^5$\n一个重要的分析是，先移动棋子，然后移动传送门，等价于棋子和传送门同时沿一条边移动，花费为1。然后假设棋子最终停在某一个节点上，将棋子移动回传送门，同样不增加花费。这样初始状态和终止状态，棋子和传送门都在相同的位置。\n这样我们要考虑的就是从哪一个节点开始走、到哪一个节点停止。假设没有传送门，显然问题的答案是$2(N-1)-d$其中$d$是直径。如果考虑传送门，那么需要考虑传送门是否跟着棋子一起走，如果跟着走，是否还会回到原位置。\n可以考虑如下树形DP。\n$dp[v][0]$表示当前子树没有传送门从$v$开始的遍历花费，显然是经典问题，维护最大深度和子树大小即可。\n$dp[v][1]$表示当前子树棋子和传送门都在$v$，且终点不在该子树中的遍历花费。对于每一个子树，考虑传送门是否跟着走，如果跟着走，走一条边的花费是2\n$dp[v][2]$表示当前子树棋子和传送门都在$v$，且终点在该子树中的遍历花费。考虑在当前根节点处终止，花费就是$dp[v][1]$，否则找一个子树终止，其它子树按传送门跟着走和不跟着走的决策讨论。\n这样解决了从1节点开始的遍历问题，考虑从任意节点开始的遍历问题，显然换根DP即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 int Main() { int n; read(n); std::vector adj(n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1, u, v; i \u0026lt;= n - 1; ++i) { read(u, v); adj[u].push_back(v), adj[v].push_back(u); } std::vector\u0026lt;int\u0026gt; size(n + 1), dep(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; mxdep(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; dp(n + 1); std::function\u0026lt;void(int, int)\u0026gt; DP = [\u0026amp;](int u, int fa) -\u0026gt; void { size[u]++; dep[u] = dep[fa] + 1; mxdep[u][0] = dep[u]; if (fa != 0) adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa)); for (int v : adj[u]) DP(v, u); for (int v : adj[u]) { size[u] += size[v]; if (mxdep[v][0] \u0026gt; mxdep[u][0]) { mxdep[u][1] = mxdep[u][0]; mxdep[u][0] = mxdep[v][0]; } else mxdep[u][1] = std::max(mxdep[u][1], mxdep[v][0]); } dp[u][0] = 2 * (size[u] - 1) - (mxdep[u][0] - dep[u]); int tmp = 0; for (int v : adj[u]) tmp += std::min(dp[v][0] + 1, dp[v][1] + 2); dp[u][2] = dp[u][1] = tmp; for (int v : adj[u]) dp[u][2] = std::min(dp[u][2], tmp - std::min(dp[v][0] + 1, dp[v][1] + 2) + dp[v][2] + 1); // printf(\u0026#34;dp[%d] = {%d, %d, %d}\\n\u0026#34;, u, dp[u][0], dp[u][1], dp[u][2]); }; DP(1, 0); int ans = std::numeric_limits\u0026lt;int\u0026gt;::max(); std::function\u0026lt;void(int, int, std::array\u0026lt;int, 3\u0026gt;)\u0026gt; reroot = [\u0026amp;](int u, int dist, std::array\u0026lt;int, 3\u0026gt; from) { int tmp = 0; ans = std::min({ans, dp[u][1] + std::min(from[0] + 1, from[1] + 2), dp[u][1] + from[2] + 1, dp[u][2] + std::min(from[0] + 1, from[1] + 2)}); std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; pre(adj[u].size() + 1), suf(adj[u].size() + 2); for (int i = 1; i \u0026lt;= adj[u].size(); ++i) { int v = adj[u][i - 1]; pre[i][0] = pre[i - 1][0] + std::min(dp[v][0] + 1, dp[v][1] + 2); pre[i][1] = std::min(pre[i - 1][0] + dp[v][2] + 1, pre[i - 1][1] + std::min(dp[v][0] + 1, dp[v][1] + 2)); } for (int i = adj[u].size(); i \u0026gt;= 1; --i) { int v = adj[u][i - 1]; suf[i][0] = suf[i + 1][0] + std::min(dp[v][0] + 1, dp[v][1] + 2); suf[i][1] = std::min(suf[i + 1][0] + dp[v][2] + 1, suf[i + 1][1] + std::min(dp[v][0] + 1, dp[v][1] + 2)); } for (int i = 1; i \u0026lt;= adj[u].size(); ++i) { int v = adj[u][i - 1]; std::array\u0026lt;int, 3\u0026gt; f{}; int mxd = (mxdep[v][0] == mxdep[u][0]) ? mxdep[u][1] : mxdep[u][0]; mxd -= dep[u]; mxd = std::max(dist, mxd); f[0] = 2 * (n - size[v] - 1) - mxd; f[1] = std::min(from[0] + 1, from[1] + 2) + suf[i + 1][0] + pre[i - 1][0]; f[2] = std::min({f[1], from[2] + 1 + suf[i + 1][0] + pre[i - 1][0], std::min(from[0] + 1, from[1] + 2) + suf[i + 1][1] + pre[i - 1][0], std::min(from[0] + 1, from[1] + 2) + suf[i + 1][0] + pre[i - 1][1]}); reroot(v, mxd + 1, f); } }; reroot(1, 0, {-1, -2, -1}); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } 总结一下：最重要的一步是合并操作3和操作1，这样传送门的决策就变少了，对于原题的分析就简化了。回传送门的操作没有额外花费，化简了终止状态。这样整个问题剩下的思路就很自然，从子树DP到换根DP都是经典问题。所以问题的解决要挖掘性质，方便分析或者程序处理。\nABC332G.Not Too Many Balls 有$N$种球，每种球有$A[i]$个。$M$个盒子，每种盒子有$B[i]$的容量。第$i$种球在第$j$个盒子里最多放$i \\times j$个。问最多能放多少个球。\n$N \\leq 500, M \\leq 5 \\times 10^5$\n好好好，好题。\n首先是个很显然的最大流的模型。但是二分图每两个点之间都有边，边数超多。\n然后是重点转化过程——从最大流转化到最小割。然后有三种边要割，$S$到$A[i]$的边，$A[i]$到$B[j]$的边，$B[j]$到$T$的边。由于是最小割，所以一旦割了$S-\u0026gt;A[i]$的边，就不用考虑$A[i]$往后的边。\n假设枚举割掉的源点相连的边集$U$，剩余集合是$V$，那么$B[j]$有两种决策，要么对于$V$到$B[j]$都割掉，要么割掉$B[j]$。发现前者对应的是$V$中节点标号之和与$j$的乘积，显然对于不同的$V$只要节点标号之和相同，对应的$j$的决策肯定相同。不妨直接枚举节点标号之和$sum$。\n这样需要计算的变成了两个部分——对于$A[i]$，节点标号之和为$N(N+1)/2-sum$时的最小$A[i]$之和——显然是个背包；对于$B[j]$，选择$min(B[j],sum * j)$，按顺序枚举$sum$之后就是个单调性问题。两者独立，然后加和求最小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 int Main() { int n, m; read(n, m); std::vector\u0026lt;ll\u0026gt; a(n + 1), b(m + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); for (int i = 1; i \u0026lt;= m; ++i) read(b[i]); int w = n * (n + 1) / 2; std::vector dp(2, std::vector\u0026lt;ll\u0026gt;(w + 1, std::numeric_limits\u0026lt;ll\u0026gt;::max())); dp[0][0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= w; ++j) { if (dp[0][j] != std::numeric_limits\u0026lt;ll\u0026gt;::max()) dp[1][j] = std::min(dp[0][j], dp[1][j]); if (j \u0026gt;= i \u0026amp;\u0026amp; dp[0][j - i] != std::numeric_limits\u0026lt;ll\u0026gt;::max()) dp[1][j] = std::min(dp[0][j - i] + a[i], dp[1][j]); } std::swap(dp[1], dp[0]); } std::vector\u0026lt;std::pair\u0026lt;ll, int\u0026gt;\u0026gt; c(m + 1); for (int i = 1; i \u0026lt;= m; ++i) c[i] = {b[i], i}; std::sort(c.begin() + 1, c.end(), [\u0026amp;](auto l, auto r) { return l.first * r.second \u0026gt; r.first * l.second; }); std::vector\u0026lt;std::array\u0026lt;ll, 2\u0026gt;\u0026gt; sum(m + 1); for (int i = 1; i \u0026lt;= m; ++i) sum[i][0] = sum[i - 1][0] + c[i].first, sum[i][1] = sum[i - 1][1] + c[i].second; ll ans = std::numeric_limits\u0026lt;decltype(ans)\u0026gt;::max(); for (int s = w, p = 1; s \u0026gt;= 0; --s) { if (dp[0][w - s] == std::numeric_limits\u0026lt;ll\u0026gt;::max()) continue; while (p \u0026lt;= m \u0026amp;\u0026amp; c[p].first \u0026gt; 1ll * c[p].second * s) p++; ans = std::min(ans, dp[0][w - s] + sum[p - 1][1] * s + sum[m][0] - sum[p - 1][0]); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } 总结一下：这个最小割的转化太惊人了。我是没想到的。但是是有端倪的，从本质上说这是一个完全二分图而且点权是一个简单的式子，应该会存在简单的做法。其实转化到最小割之后整个思路就很自然了，从复杂的集合枚举到找到集合最有用的特征，然后归约到已知问题，这是一个常见的CP题目分析法。\nARC173D.Bracket Walk 在一个$N$个点$M$条边的单向强连通图中，每条边要么是(要么是)。判定是否存在一个经过了所有边至少一次，且遍历顺序是一个合法的括号序列的环。$N \\leq 4000, M\\leq8000$\n首先这个环不一定非得是合法的括号序列，只要正反括号数量相等即可。设正反括号权值分别为1和-1，只要找到最小的负数前缀和，从这个点开始走，就是一个合法的括号序列了。\n所有要找的是一个权值为0的环。\n因为图强联通，所有必然存在一个环经过了所有边。假设这个环的权值是正数，相当于我们要拿一些负数去找补成0。只要存在一个负数环，就可以找补成0。因为组成正数权值和负数权值的LCM，加起来就是0了。对于这个环权值是负数也是一样的。\n所以问题变成，是否存在正数环以及负数环；如果都存在或都不存在，答案是Yes；否则答案是No，因为永远找补不回0。\n搜环是Spfa的一个子应用，套用即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 int Main() { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); std::vector adj(n + 1, std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt;{}); for (int i = 1; i \u0026lt;= m; ++i) { int u, v; char c[2]; scanf(\u0026#34;%d%d%s\u0026#34;, \u0026amp;u, \u0026amp;v, c); int w = (c[0] == \u0026#39;(\u0026#39;) ? 1 : -1; adj[u].push_back({v, w}); } auto BellmanFord = [\u0026amp;]() -\u0026gt; bool { std::vector\u0026lt;int\u0026gt; dist(n + 1), cnt(n + 1); std::vector\u0026lt;bool\u0026gt; vis(n + 1); std::queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) q.push(i), vis[i] = true; while (!q.empty()) { int u = q.front(); vis[u] = false; cnt[u]++; if (cnt[u] \u0026gt; n) return true; q.pop(); for (auto [v, w] : adj[u]) { if (dist[v] \u0026lt; dist[u] + w) { dist[v] = dist[u] + w; if (!vis[v]) q.push(v), vis[v] = true; } } } return false; }; bool neg = BellmanFord(); for (int i = 1; i \u0026lt;= n; ++i) for (auto \u0026amp;[_, w] : adj[i]) w = -w; bool pos = BellmanFord(); bool res = neg ^ pos ^ 1; if (res) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); return 0; } 总结一下：有点抽象的推理题。解法有点像局部搜索，假设有一个解，然后用这个解去靠近最优解，然后分析性质才能得到解的充要条件。CP题需要很多假设以及简单的暴力，要有抽象思考问题的能力。能不着眼于具体的case，眼光着眼于整个问题才能得到优秀的解法。\nARC176D.Swap Permutation 给出一个长度为$N$的排列$P$，每次操作任选两个不相等的下标$i$和$j$，交换$P[i]$和$P[j]$。求所有可能的$M$次操作后，$\\sum_{i=1}^{N-1}|P[i]-P[i+1]|$值。\n只能说是学到新东西了。\n设$l=min(P[i],P[i+1]),r=max(P[i],P[i+1])$，一对间隔的计算相当于数$l\u0026lt;k\\leq r$的$k$的数量。假设枚举$k$，找到每个$k$能提供贡献的位置和数量就可以计算总贡献。据说这个叫切糕模型，来源于一个网络流题目\n[HNOI2013] 切糕，会去补一下。考虑把原序列转化为01串$s$，$s[i]=P[i]\\geq k$，那么显然在$s$串中01和10的出现会提供贡献。\n接下来是一个神奇的东西。\n因为每次交换是等概率选取一对数而且每次操作独立，所以每个状态到新状态的选法是一样的。很新奇的思路。\n假设原串中一个00，意味着$P[i]\u0026lt;k,P[i+1]\u0026lt;k$，变成同样是00的位置，方案有\n选一个$i,i+1$之外的小于$k$的数，一共有$k-3$个，跟$i$和$i+1$交换，一共有$2(k-3)$种选法； 交换$i,i+1$，显然只有一种 交换除了$i,i+1$之外的两个数，一共是$C_{n-2}^{2}$种选法 所以最终能写出一个矩阵$Mat$。\n$Mat=\\begin{bmatrix} C_{n-2}^{2}+2(k-3)+1\u0026amp;n-k+1\u0026amp;n-k+1\u0026amp;0\\ k-2\u0026amp;C_{n-2}^{2}+n-2\u0026amp;1\u0026amp;n-k\\ k-2\u0026amp;1\u0026amp;C_{n-2}^{2}+n-2\u0026amp;n-k\\ 0\u0026amp;k-1\u0026amp;k-1\u0026amp;C_{n-2}^{2}+2(n-k-1)+1 \\end{bmatrix}$。那么经过$M$次操作，状态的变换就是$Mat^m$。\n接下来只需要枚举$k$，统计原序列中00,01,10,11的出现数做成一个向量$v$。经过矩阵的变换，求解变换之后的方案数，对总答案贡献即可。看起来是$O(N^2 * 4^3 * log_{2}M)$，实际上每次枚举到一个新的$k$，只需要关注$p[i]=k-1$前后的两个位置，去更新$v$即可。复杂度是$O(N * 4^3 * log_{2}M)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;atcoder/modint\u0026gt; using modint = atcoder::modint998244353; struct Matrix { std::array\u0026lt;std::array\u0026lt;modint, 4\u0026gt;, 4\u0026gt; a{}; Matrix operator*(const Matrix \u0026amp;rhs) const { Matrix res{}; for (int i = 0; i \u0026lt; 4; ++i) for (int j = 0; j \u0026lt; 4; ++j) for (int k = 0; k \u0026lt; 4; ++k) res.a[i][j] += a[i][k] * rhs.a[k][j]; return res; } }; Matrix quick_pw(Matrix a, ll b) { static Matrix I{std::array\u0026lt;std::array\u0026lt;modint, 4\u0026gt;, 4\u0026gt;{std::array\u0026lt;modint, 4\u0026gt;{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}}}; if (b == 0) return I; Matrix ans = I, base = a; while (b) { if (b \u0026amp; 1) ans = ans * base; b \u0026gt;\u0026gt;= 1; base = base * base; } return ans; } int Main() { int n, m; read(n, m); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(p[i]); std::vector\u0026lt;int\u0026gt; pos(n + 1); for (int i = 1; i \u0026lt;= n; ++i) pos[p[i]] = i; std::array\u0026lt;modint, 4\u0026gt; v{0, 0, 0, n - 1}; modint ans = 0; for (int k = 2; k \u0026lt;= n; ++k) { Matrix mat{}; if (int pre = pos[k - 1] - 1; pre) { if (p[pre] \u0026gt;= k) v[3] -= 1, v[2] += 1; else v[1] -= 1, v[0] += 1; } if (int suf = pos[k - 1] + 1; suf \u0026lt;= n) { if (p[suf] \u0026gt;= k) v[3] -= 1, v[1] += 1; else v[0] += 1, v[2] -= 1; } mat.a[0][0] = 1ll * (n - 3) * (n - 2) / 2 + std::max(0, k - 3) * 2 + 1; mat.a[0][1] = n - k + 1, mat.a[0][2] = n - k + 1; mat.a[1][0] = k - 2, mat.a[1][1] = 1ll * (n - 3) * (n - 2) / 2 + n - k + k - 2, mat.a[1][2] = 1, mat.a[1][3] = n - k; mat.a[2][0] = k - 2, mat.a[2][1] = 1, mat.a[2][2] = mat.a[1][1], mat.a[2][3] = n - k; mat.a[3][0] = 0, mat.a[3][1] = mat.a[3][2] = k - 1, mat.a[3][3] = 1ll * (n - 3) * (n - 2) / 2 + std::max(0, n - k - 1) * 2 + 1; mat = quick_pw(mat, m); std::array\u0026lt;modint, 4\u0026gt; res{}; for (int i = 0; i \u0026lt; 4; ++i) for (int j = 0; j \u0026lt; 4; ++j) res[i] += v[j] * mat.a[j][i]; ans += res[1] + res[2]; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 第二种解法：\n实际上这种可以分拆贡献的题目，一般都直接考虑贡献——即$P[i]$和$P[j]$如何向答案提供贡献。\n对于这种交换操作，有一个普适的做法。来源于P4223 期望逆序对。\n考虑两个位置$L$和$R$，其数字是$A_{L}$和$A_R$，设其它数字是$A_{other}$。经过交换之后，$L$和$R$上的数字会有七种状态——$(A_L,A_R),(A_L,A_{other}),(A_R,A_L),(A_R,A_{other}),(A_{other},A_L),(A_{other},A_R),(A_{other},A_{other})$。\n同样跟解法1一样，写出矩阵$Mat$。\n$Mat=\\begin{bmatrix} C_{n-2}^{2}\u0026amp;n-2\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;n-2\u0026amp;0\\ 1\u0026amp;C_{n-2}^2+n-3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;n-3\\ 1\u0026amp;0\u0026amp;C_{n-2}^2\u0026amp;n-2\u0026amp;n-2\u0026amp;0\u0026amp;0\\ 0\u0026amp;1\u0026amp;1\u0026amp;C_{n-2}^{2}+n-3\u0026amp;0\u0026amp;1\u0026amp;n-3\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;C_{n-2}^{2}+n-3\u0026amp;1\u0026amp;n-3\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;C_{n-2}^{2}+n-3\u0026amp;n-3\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;C_{n-2}^2+2(n-4)+1\\ \\end{bmatrix}$\n通过初始向量$v=(1,0,0,0,0,0,0)$，$v *= Mat^M$，这样任意两个位置在交换$M$次之后的状态以及对应的方案数都确定了。接下来考虑贡献。\n因为这里的贡献只有$P[i]$和$P[i+1]$，考虑在$M$次交换之后，各状态对答案的贡献。\n首先最好考虑的就是$(A_L,A_R)$以及$(A_R,A_L)$两个状态的贡献。显然是$(v[0]+v[2])\\times|P[i]-P[i+1]|$。对于$(A_{other},A_L)$，因为$A_{other}$有$n-2$种可能，每种可能性出现的次数都是均等的，所以单个可能是$\\frac{v[1]}{n-2}$。考虑$f(x)=\\sum_{i=1}^N|i-x|$，贡献数是$\\frac{v[1]\\times[f(P[i])-|P[i]-P[i+1]|]}{n-2}$。接下来的贡献同理。\n考虑状态$(A_{other},A_{other})$的贡献数。一共有$(n-2)(n-3)$种均等的可能性。通过枚举第一个$A_{other}$的值，可以得到贡献为$\\frac{v[6]\\times(\\sum_{x=1}^Nf(x)-2f(P[i])-2f(P[i+1])+2|P[i]-P[i+1]|)}{(n-2)(n-3)}$。\n最终复杂度为$O(N+7^3log_{2}M)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 #include \u0026lt;atcoder/modint\u0026gt; using modint = atcoder::modint998244353; template \u0026lt;class T, int SIZE = 2\u0026gt; struct Matrix { std::array\u0026lt;std::array\u0026lt;T, SIZE\u0026gt;, SIZE\u0026gt; a{}; Matrix(T v = 0) { for (int i = 0; i \u0026lt; SIZE; ++i) a[i][i] = v; } Matrix operator*(const Matrix \u0026amp;rhs) const { Matrix res{}; for (int i = 0; i \u0026lt; SIZE; ++i) for (int j = 0; j \u0026lt; SIZE; ++j) for (int k = 0; k \u0026lt; SIZE; ++k) res.a[i][j] += a[i][k] * rhs.a[k][j]; return res; } std::array\u0026lt;T, SIZE\u0026gt; \u0026amp;operator[](int i) { return a[i]; } const std::array\u0026lt;T, SIZE\u0026gt; \u0026amp;operator[](int i) const { return a[i]; } }; template \u0026lt;class T\u0026gt; T quick_pw(T a, ll b) { static T I{1}; if (b == 0) return I; Matrix ans = I, base = a; while (b) { if (b \u0026amp; 1) ans = ans * base; b \u0026gt;\u0026gt;= 1; base = base * base; } return ans; } int Main() { int n, m; read(n, m); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(p[i]); std::vector\u0026lt;int\u0026gt; pos(n + 1); for (int i = 1; i \u0026lt;= n; ++i) pos[p[i]] = i; std::vector\u0026lt;modint\u0026gt; f(n + 1); f[1] = 1ll * n * (n - 1) / 2; for (int i = 2; i \u0026lt;= n; ++i) f[i] = f[i - 1] + i - 1 - (n - i + 1); modint sum = std::accumulate(f.begin(), f.end(), modint(0)); Matrix\u0026lt;modint, 7\u0026gt; M{}; modint c_n_2_2 = 1ll * (n - 3) * (n - 2) / 2; modint inv_n_2 = 1, inv_n_3 = 1; if (n - 2) inv_n_2 /= (n - 2); if (n - 3) inv_n_3 /= (n - 3); M[0][0] = c_n_2_2, M[0][1] = n - 2, M[0][2] = 1, M[0][5] = n - 2; M[1][0] = 1, M[1][1] = c_n_2_2 + n - 3, M[1][3] = M[1][4] = 1, M[1][6] = n - 3; M[2][0] = 1, M[2][2] = c_n_2_2, M[2][3] = M[2][4] = n - 2; M[3][1] = M[3][2] = 1, M[3][3] = c_n_2_2 + n - 3, M[3][5] = 1, M[3][6] = n - 3; M[4][1] = M[4][2] = 1, M[4][4] = M[3][3], M[4][5] = 1, M[4][6] = n - 3; M[5][0] = M[5][3] = M[5][4] = 1, M[5][5] = c_n_2_2 + n - 3, M[5][6] = n - 3; M[6][1] = M[6][3] = M[6][4] = M[6][5] = 1, M[6][6] = c_n_2_2 + 2 * (n - 4) + 1; M = quick_pw(M, m); modint ans = 0; auto v = M[0]; for (int i = 1; i \u0026lt;= n - 1; ++i) { modint diff = std::abs(p[i] - p[i + 1]); ans += (v[0] + v[2]) * diff; ans += (v[1] + v[4]) * inv_n_2 * (f[p[i]] - diff); ans += (v[3] + v[5]) * inv_n_2 * (f[p[i + 1]] - diff); ans += v[6] * inv_n_2 * inv_n_3 * (sum - 2 * (f[p[i]] + f[p[i + 1]]) + 2 * diff); } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } int main() { int TestCases = 1; if constexpr (MultiTestCases == 1) scanf(\u0026#34;%d\u0026#34;, \u0026amp;TestCases); while (TestCases--) Main(); return 0; } 总结一下：新的东西出现了！第一个是切糕模型，这种拆贡献的方式确实厉害了。第二个是这个矩阵的做法，任意且独立的多次操作，状态压缩之后通过矩阵推导最终状态的方案，然后再单独算贡献。相当于把可能性都展现出来，然后只用考虑单次操作对状态的变化（就简单很多），最终利用快速幂来压缩运算。\n要去补一下提到的两道题。留个白先。\n切糕问题：看了一眼感觉跟这题没啥关系啊，可能他的切糕模型跟那个题不一样吧。这个建模是指在最小割里面怎么添加无穷容量的边的问题；\nP4223 期望逆序对：一个排列，每轮任选两个数交换，一共$k$轮，求所有操作序列最终带来的逆序对总和。 就直接从7种状态对答案的贡献开始讨论好了 $(A_L,A_R)$对答案产生贡献，说明原先是一个逆序对； $(A_R,A_L)$对答案产生贡献，说明原先是一个顺序对； $(A_{other}, A_L)$对答案产生贡献，那么$A_{other}\u0026gt;A_L$且$A_{other}\\neq A_R$。那么对于原先的一个顺序对$(A_L,A_R)$，提供的贡献就是$\\frac{N-A_L-1}{N-2}$；对于一个逆序对$(A_L,A_R)$，提供的贡献是$\\frac{N-A_L}{N-2}$ $(A_{other}, A_R)$对答案产生贡献，那么$A_{other}\u0026gt;A_R$且$A_{other}\\neq A_L$。那么对于原先的一个顺序对$(A_L,A_R)$，提供的贡献就是$\\frac{N-A_R}{N-2}$；对于一个逆序对$(A_L,A_R)$，提供的贡献是$\\frac{(N-A_R-1)}{N-2}$。 $(A_{L}, A_{other})$对答案产生贡献，那么$A_{other}\u0026lt;A_L$且$A_{other}\\neq A_R$。那么对于原先的一个顺序对$(A_L,A_R)$，提供的贡献就是$\\frac{A_L-1}{N-2}$；对于一个逆序对$(A_L,A_R)$，提供的贡献是$\\frac{A_L-2}{N-2}$ $(A_{R}, A_{other})$对答案产生贡献，那么$A_{other}\u0026lt;A_R$且$A_{other}\\neq A_L$。那么对于原先的一个顺序对$(A_L,A_R)$，提供的贡献就是$\\frac{A_R-2}{N-2}$；对于一个逆序对$(A_L,A_R)$，提供的贡献是$\\frac{A_R-1}{N-2}$ $(A_{other},A_{other})$，产生$\\frac{1}{2}$的贡献，且对于每一对数都成立\n那么就直接在求顺序对和逆序对的时候直接计算贡献即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int Main() { int n, k; read(n, k); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(p[i]); FenwickTree\u0026lt;int\u0026gt; fwt(n); modint ans = 0; Matrix\u0026lt;modint, 7\u0026gt; M{}; modint c_n_2_2 = 1ll * (n - 3) * (n - 2) / 2; M[0][0] = c_n_2_2, M[0][1] = n - 2, M[0][2] = 1, M[0][5] = n - 2; M[1][0] = 1, M[1][1] = c_n_2_2 + n - 3, M[1][3] = M[1][4] = 1, M[1][6] = n - 3; M[2][0] = 1, M[2][2] = c_n_2_2, M[2][3] = M[2][4] = n - 2; M[3][1] = M[3][2] = 1, M[3][3] = c_n_2_2 + n - 3, M[3][5] = 1, M[3][6] = n - 3; M[4][1] = M[4][2] = 1, M[4][4] = M[3][3], M[4][5] = 1, M[4][6] = n - 3; M[5][0] = M[5][3] = M[5][4] = 1, M[5][5] = c_n_2_2 + n - 3, M[5][6] = n - 3; M[6][1] = M[6][3] = M[6][4] = M[6][5] = 1, M[6][6] = c_n_2_2 + 2 * (n - 4) + 1; M = quick_pw(M, k); auto v = M[0]; modint n_2_inv = n - 2 ? modint(n - 2).inv() : 0; for (int i = 1; i \u0026lt;= n; ++i) { modint ord = fwt.query(p[i]), inv = i - 1 - ord; ans += ord * v[2] + inv * v[0]; ans += inv * (p[i] - 1) * n_2_inv * v[3] + ord * (p[i] - 2) * n_2_inv * v[3]; ans += inv * (n - p[i] - 1) * n_2_inv * v[5] + ord * (n - p[i]) * n_2_inv * v[5]; fwt.modify(p[i], 1); } for (int i = 1; i \u0026lt;= n; ++i) fwt.modify(p[i], -1); for (int i = n; i \u0026gt;= 1; --i) { modint inv = fwt.query(p[i]), ord = n - i - inv; ans += inv * (p[i] - 2) * n_2_inv * v[1] + ord * (p[i] - 1) * n_2_inv * v[1]; ans += inv * (n - p[i]) * n_2_inv * v[4] + ord * (n - p[i] - 1) * n_2_inv * v[4]; fwt.modify(p[i], 1); } ans += 1ll * n * (n - 1) / 2 * modint(2).inv() * v[6]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } P.S.：\n两种做法差好多啊。。。第一个做法有一个64的常数。但第二个做法写矩阵有点痛苦\u0026hellip;\nARC163D.Sum of SCC 一个$N$个节点的竞赛图，需要有$M$条边是从小编号连到大编号。问所有满足条件的图，强连通分量（SCC）的总数是多少。\n$N\\leq30, M\\leq \\frac{N(N-1)}{2}$\n竞赛图是把一个完全图的边定向之后的有向图。\n这样的话把竞赛图进行SCC缩点，会形成一条链，且每个节点向后续节点都有边。\n每个SCC的大小，节点编号都很难确定。直接从SCC的角度考虑很费劲。而且$M$条边从小编号连到大编号这种限制，似乎感觉在告诉我们从小到大加节点，然后给边定向，这样方便满足这个限制。这样的话每次加一个节点，还可能会破坏之前枚举的SCC的链结构。\n直接计数很费劲的话，考虑能否构造一一映射。\n一个定理：\n考虑将图分为两个集合$A$和$B$($B$非空)，使得两个集合之间，只有$A$连到$B$的边。竞赛图的SCC个数，等价于这个集合划分方案数。\n实际上这个定理是缩链之后的一个引理。因为划分集合的方案，等价于在这条链上按拓扑序一分为二，显然是SCC-1种切分。这样如果$B$不为空$A$可以为空，就恰好是SCC的个数。\n这样就可以考虑维护这个$A$集合和$B$集合。枚举$A$集合，每次加一个新节点进来只需要考虑两个决策——节点分在哪个集合中。发现新节点构造边的方案数实际上只跟$A$集合的大小有关，那么压缩$A$集合的状态为枚举大小。\n$dp[i][j][k]$表示前$i$个节点，$A$集合大小为$j$，满足条件的边有$k$个。\n假设$i+1$分到$A$集合中，首先$i+1$向$B$集合连边，编号从大连到小；剩下的边在$A$集合内部，可以随意连。设有$x$个节点连向$i+1$，则$dp[i+1][j+1][k+x] += dp[i][j][k]\\times C_{j}^{x}$\n假设$i+1$分到$B$集合中，那么$A$集合所有点向$i+1$连边，编号从小连到大；剩下的边在$B$集合内部，设有$x$个节点连向$i+1$，则$dp[i+1][j][k+j+x] += dp[i][j][k]\\times C_{i-j}^{x}$。\n最终去掉空集$B$的方案即可；否则，对于每一种可能的图都多加了1，要减去$2^{\\frac{N(N-1)}{2}}$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;atcoder/modint\u0026gt; using modint = atcoder::modint998244353; int Main() { int n, m; read(n, m); std::vector dp(n + 1, std::vector(n + 1, std::vector\u0026lt;modint\u0026gt;(m + 1))); std::vector C(n + 1, std::vector\u0026lt;modint\u0026gt;(n + 1)); C[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { C[i][0] = 1; for (int j = 1; j \u0026lt;= i; ++j) C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; } dp[0][0][0] = 1; for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt;= i; ++j) for (int k = 0; k \u0026lt;= m; ++k) { if (dp[i][j][k] == 0) continue; for (int x = 0; x \u0026lt;= j; ++x) if (k + x \u0026lt;= m) dp[i + 1][j + 1][k + x] += dp[i][j][k] * C[j][x]; for (int x = 0; x \u0026lt;= i - j; ++x) if (k + j + x \u0026lt;= m) dp[i + 1][j][k + j + x] += dp[i][j][k] * C[i - j][x]; } modint ans = 0; for (int i = 0; i \u0026lt; n; ++i) ans += dp[n][i][m]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结一下：我是想不出来的\u0026hellip;首先这个编号的限制我就没想明白，现在复盘一下觉得这是从小到大加点的一个提示。接下来是这个构造一一映射的过程，这确实计数题的一个比较典型的解法。由于SCC的结构很难用DP状态来表示，构造了这个一一映射，直接简化了问题，而且每个新节点的决策只有两种，太厉害了。感觉有的时候，有一些很冷门的知识点，如果能想到就能解决问题，比如这个竞赛图的集合划分方案，以及之前做过的一个数组LCM的问题——那道题需要知道若干数的最小公倍数的质因数分解中每个因数的指数是数组中该因数的最大指数，当然那道题我想到了，这个状态就可以用一个bitmask来表示。的确有时候需要这种灵感以及知识点，灵感这个东西靠经验，知识点就得靠积累了，多做题肯定是没错的。\nABC321G.Electric Circuit 一个$N$个节点的图，两个长度为$M$的序列$R$和$B$。每次加边选择$R$和$B$中没被选择的一个，一共有$M!$种加边方法。求所有加边方法，最终形成的连通块数量的期望\n$M\\leq 10^5, N\\leq 17$\n因为一共有$M!$种加边法，所有求所有加边法的连通块总数即可。\n很自然能想到枚举连通块的点集，为总数做贡献。设点集为$S$的单个连通块的构建方法为$f(S)$，点集$S$在$R$和$B$中各出现了$k$次，显然对总数的贡献是$f(S) * (M-k)!$。\n求$f(S)$感觉很困难，此时我想到利用前缀和差分的方式求。但觉得复杂度高弃了真是有点大病。\n点集为$S$的点，连边的方案一共是$k!$。取这个点集的一个长度为$l$的子集划分${s_1,\u0026hellip;,s_l}$。每一个不同的子集划分，方案是不会有重复的。这样$k! = \\sum_{S={s_1,\u0026hellip;,s_l}} \\prod_{i=1}^{l}f(s_i)$。$f(S)$就等价于长度为1的子集划分。这样可以枚举子集做一个差分，为了避免重复计算，取点集最大编号的那个点所在的集合$s_l$来做。即$f(S)=k!-\\sum_{s_l}f(s_l)[\\sum_{S-s_l = {s1,\u0026hellip;,s_l-1}}\\prod_{i=1}^{l-1}f(s_i)]$，后面的显然可以利用前缀和一类的东西来计算子问题。这样就做完了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;atcoder/modint\u0026gt; using modint = atcoder::modint998244353; int Main() { int n, m; read(n, m); std::array\u0026lt;std::vector\u0026lt;int\u0026gt;, 2\u0026gt; a{std::vector\u0026lt;int\u0026gt;(m + 1), std::vector\u0026lt;int\u0026gt;(m + 1)}; for (int p = 0; p \u0026lt; 2; ++p) for (int i = 1; i \u0026lt;= m; ++i) read(a[p][i]), a[p][i]--; std::array\u0026lt;std::vector\u0026lt;int\u0026gt;, 2\u0026gt; cnt{std::vector\u0026lt;int\u0026gt;(n), std::vector\u0026lt;int\u0026gt;(n)}; for (int p = 0; p \u0026lt; 2; ++p) for (int i = 1; i \u0026lt;= m; ++i) cnt[p][a[p][i]]++; std::vector\u0026lt;modint\u0026gt; factor(m + 1); factor[0] = 1; for (int i = 1; i \u0026lt;= m; ++i) factor[i] = factor[i - 1] * i; std::vector\u0026lt;modint\u0026gt; f(1 \u0026lt;\u0026lt; n), g(1 \u0026lt;\u0026lt; n); f[0] = 1; modint ans = 0; for (int mask = 1; mask \u0026lt; (1 \u0026lt;\u0026lt; n); ++mask) { int mx = -1; std::array\u0026lt;int, 2\u0026gt; tmp{}; for (int i = 0; i \u0026lt; n; ++i) if (mask \u0026amp; (1 \u0026lt;\u0026lt; i)) mx = i, tmp[0] += cnt[0][i], tmp[1] += cnt[1][i]; if (tmp[0] != tmp[1]) continue; modint all = factor[tmp[0]]; g[mask] = 0; for (int S = (mask ^ (1 \u0026lt;\u0026lt; mx)), T = S; T; T = (T - 1) \u0026amp; S) g[mask] += g[T] * f[mask ^ T]; f[mask] = all - g[mask]; g[mask] += f[mask]; ans += f[mask] * factor[m - tmp[0]]; } printf(\u0026#34;%d\\n\u0026#34;, ans / factor[m]); return 0; } 总结一下：不能因为感觉困难就放弃思考放弃治疗啊！！！明明自己已经整理过反演相关的东西了，为什么放弃治疗了！！\nARC165D.Substring Comparison 假设有一个长为$N$字符串$X$，给出$M$条限制，每条限制是$X[A_{i},B_i]$在字典序上比$X[C_i,D_i]$小。求是否有这样的字符串。\n$N\\leq 2000, M\\leq 2000$\n考虑字典序小，说明可能有一段LCP，然后在$X[A_i+LCP]$和$X[C_i+LCP]$的地方比出大小。一般这种给出$M$条限制的可以按图论考虑。这样就可以利用有向图来刻画“小于”的偏序关系。\n维护每个限制的LCP，将当前要比较的一位按偏序连边。如果最终这个图出现了自环或者SCC，说明有当前偏序未能满足，且有部分位置的字符一定是相等的，这时将未能满足的限制的LCP加1，重复这个过程。注意到每次新过程需要保存老过程的SCC，因为需要维护字符的相等，这样每轮的图边数一共有$O(NM)$条，会TLE。实际上老过程的SCC可以直接用DSU缩点，这样每轮的图边数一共有$O(M)$条。另外如果出现了新的SCC，会多跑一轮，一个$N$个节点的图，SCC数量只会从$N$减到1，这样出现新的SCC时，相当于缩点之后的图节点变少了，于是最多跑$N$轮。复杂度是$O(N(N+M))$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include \u0026lt;atcoder/dsu\u0026gt; std::pair\u0026lt;int, std::vector\u0026lt;int\u0026gt;\u0026gt; Tarjan(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;G, int n) { std::vector\u0026lt;int\u0026gt; dfn(n + 1), low(n + 1), scc(n + 1); std::stack\u0026lt;int\u0026gt; stack; std::vector\u0026lt;bool\u0026gt; ins(n + 1); int stamp = 0, cnt = 0; std::function\u0026lt;void(int)\u0026gt; tarjan = [\u0026amp;](int u) { // int t, minc = low[v] = pre[v] = cnt++; stack.push(u), ins[u] = true; dfn[u] = low[u] = ++stamp; for (int v : G[u]) { if (!dfn[v]) { tarjan(v); low[u] = std::min(low[v], low[u]); } else if (ins[v]) low[u] = std::min(low[u], dfn[v]); } if (dfn[u] != low[u]) return; cnt++; int t = 0; do { ins[t = stack.top()] = false; scc[t] = cnt; stack.pop(); } while (t != u); }; for (int i = 1; i \u0026lt;= n; ++i) if (!dfn[i]) tarjan(i); return {cnt, scc}; } int Main() { int n, m; read(n, m); std::vector\u0026lt;std::array\u0026lt;int, 5\u0026gt;\u0026gt; e(m + 1); for (int i = 1; i \u0026lt;= m; ++i) { auto \u0026amp;[a, b, c, d, lcp] = e[i]; read(a, b, c, d); lcp = 0; } std::vector adj(n + 1, std::vector\u0026lt;int\u0026gt;{}); atcoder::dsu dsu(n + 1); while (true) { for (int i = 1; i \u0026lt;= n; ++i) adj[i].clear(); bool self_loop = false; for (int i = 1; i \u0026lt;= m; ++i) { auto [a, b, c, d, lcp] = e[i]; int u = a + lcp, v = c + lcp; if (u \u0026gt; b) continue; u = dsu.leader(u), v = dsu.leader(v); adj[u].push_back(v); self_loop |= (v == u); } auto [cnt, scc] = Tarjan(adj, n); if (cnt == n \u0026amp;\u0026amp; !self_loop) return printf(\u0026#34;Yes\\n\u0026#34;), 0; for (int i = 1; i \u0026lt;= m; ++i) { auto \u0026amp;[a, b, c, d, lcp] = e[i]; int u = a + lcp, v = c + lcp; if (u \u0026gt; b) continue; u = dsu.leader(u), v = dsu.leader(v); if (scc[u] == scc[v]) lcp++, dsu.merge(u, v); if (lcp == d - c + 1) return printf(\u0026#34;No\\n\u0026#34;), 0; } } printf(\u0026#34;No\\n\u0026#34;); return 0; } 总结一下：我自己分析出来了，有点开心，这里有点后缀数组倍增的意思，实际上考虑LCP是字典序的典型解法。然后复杂度分析那块稍微卡住了，但是考虑了一下缩点，这样每轮甚至轮数都确定了，还是挺妙的。\nARC168D.Maximize Update 在一行里有$N$个方格，有$M$种操作$L_i$和$R_i$，表示将$[L_i,R_i]$这个区间全染黑；如果这个区间已经黑了就不能染了。问最多能进行几次操作。\n$N\\leq500$\n这个数据类型就挺区间DP的。然后考虑$dp[l][r]$表示$[l,r]$区间最多进行几次操作，注意这里所有的操作都不能超过$[l,r]$。然后就是枚举最后一个染黑的点$mid$，这个点目前是白的，所以之前的操作都不会越过$mid$，归约到子问题$dp[l][mid-1]$和$dp[mid+1][r]$。当然这个点能操作当且仅当在$[l,r]$中包含一个能染$mid$的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 int Main() { int n, m; read(n, m); std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; a(m + 1); for (int i = 1; i \u0026lt;= m; ++i) { auto \u0026amp;[l, r] = a[i]; read(l, r); } std::sort(a.begin() + 1, a.end()); std::vector dp(n + 1, std::vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= m; ++i) if (auto [l, r] = a[i]; l == r) dp[l][r] = 1; std::vector ok(n + 1, std::vector(n + 1, std::vector\u0026lt;int\u0026gt;(n + 1))); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { auto [l, r] = a[j]; if (l \u0026lt;= i \u0026amp;\u0026amp; r \u0026gt;= i) ok[i][l][r] = 1; } for (int l = n; l \u0026gt;= 1; --l) for (int r = 1; r \u0026lt;= n; ++r) { if (l - 1 \u0026gt;= 1) ok[i][l - 1][r] |= ok[i][l][r]; if (r + 1 \u0026lt;= n) ok[i][l][r + 1] |= ok[i][l][r]; if (l - 1 \u0026gt;= 1 \u0026amp;\u0026amp; r + 1 \u0026lt;= n) ok[i][l - 1][r + 1] |= ok[i][l][r]; } } for (int len = 2; len \u0026lt;= n; ++len) for (int l = 1; l \u0026lt;= n; ++l) { int r = l + len - 1; if (r \u0026gt; n) break; for (int mid = l; mid \u0026lt;= r; ++mid) if (ok[mid][l][r]) dp[l][r] = std::max(dp[l][r], ((l \u0026lt;= mid - 1) ? dp[l][mid - 1] : 0) + ((mid + 1 \u0026lt;= r) ? dp[mid + 1][r] : 0) + 1); } std::cout \u0026lt;\u0026lt; dp[1][n] \u0026lt;\u0026lt; std::endl; return 0; } 总结一下：挺直觉的，但是国外给的难度评级比较高，难道区间DP是CN强项？当然如果要很严谨地证还是有点复杂。\nARC162D.Smallest Vertices 假设一棵以1为根的有根树有$N$个节点，每个节点的出度是$d_i$。\n求所有这样的树里面，子树的根节点是子树编号最小的那个点，这样的点的总数。\n$N\\leq500$\n一开始看到是有根树的感觉有点复杂，后来一看以1为根，那不就是无根树的数量。\n给出每个点的出度，即意味着除了根节点外每个点度数$deg_i$都是$d_i+1$。给出点度数求树的数量，显然Prufer序列。在$N-2$个格子里面，点$i$出现了$deg_i-1$次。方案就是多重组合数$\\frac{(N-2)!}{\\prod_{i=1}^N(deg_i-1)!}$。原来出度是为了让我们不用减1了？Atcoder你人还怪好的。\n然后考虑一个节点$v$作为根的时候是子树编号最小的点。发现这样的话就相当于从$[v+1,N]$里面拿一些节点凑成一个子树。显然$v$子树有若干形状，而$v$子树外面也有若干形状。假设拿取的点是$t_1,\u0026hellip;t_k$。于是$v$子树的方案有$\\frac{(k-1)!}{\\prod_{i=1}^k(d_{t_i}!)\\times (d_v-1)!}$，$v$子树外的方案相当于把$v$子树当做一个叶子，再凑成一个新树，方案是$\\frac{(N-k-2)!}{\\prod_{i=2}^{N}[i \\notin t]d_i! \\times (d_1-1)!}$。这俩乘在一起，发现分母就是算树总数的那个分母，只不过少乘了一个$d_v$。就是$\\frac{(k-1)!(N-k-2)!d_v}{\\prod_{i=2}^{N}(d_i)! \\times (d_1-1)!}$。于是分母就能预处理出来。分子发现只跟$k$有关。\n接下来考虑如何从$[v+1,N]$里面拿子树。显然点度数的和要符合条件，一个大小为$k$的子树，节点的出度和应为$k-1$。又因为不管我们怎么取子树，上面式子的分母都是一样的，所以求一个方案数当做系数就行了。因此相当于做一个背包，$dp[i][j][k]$表示在$[i,N]$里面拿取$j$个节点，度数和为$k$的方案，按01背包去做就行了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int Main() { int N; read(N); std::vector\u0026lt;int\u0026gt; d(N + 1); for (int i = 1; i \u0026lt;= N; ++i) read(d[i]); Combinatorics\u0026lt;modint\u0026gt; combinatorics(N); std::vector dp(N + 2, std::vector(N + 1, std::vector\u0026lt;modint\u0026gt;(N + 1, 0))); dp[N + 1][0][0] = 1; // (S-2)!/(d[i]!)*(d[v]-1)! * (N-S-2)!/(d[j]!)*(d[1]-1)! modint frac = 1; for (int i = 2; i \u0026lt;= N; ++i) frac *= combinatorics.invfac[d[i]]; frac *= combinatorics.invfac[d[1] - 1]; modint ans = combinatorics.fac[N - 2] * frac; for (int i = N; i \u0026gt;= 2; --i) { if (d[i] == 0) ans += combinatorics.fac[N - 2] * frac; else { for (int j = d[i] + 1; j \u0026lt;= N - i + 1; ++j) ans += dp[i + 1][j - 1][j - 1 - d[i]] * frac * d[i] * combinatorics.fac[j - 2] * ((N - j - 1 \u0026gt;= 0) ? combinatorics.fac[N - j - 1] : 1); } for (int j = 0; j \u0026lt;= N - i + 1; ++j) for (int k = 0; k \u0026lt;= N - 1; ++k) { dp[i][j][k] += dp[i + 1][j][k]; if (j \u0026gt;= 1 \u0026amp;\u0026amp; k \u0026gt;= d[i]) dp[i][j][k] += dp[i + 1][j - 1][k - d[i]]; } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结一下：最近看房子，没有很认真地用纸笔推演。甚至一开始看错题了怎么都做不出来。最终在脑子里大致推出来一个型，虽然那个型没考虑$v$子树外的情况，但好在在洗碗的时候意识到了\u0026hellip;全程意识流，感觉Prufer序列处理点度数问题是一个经典思路，我也是从那道生成函数里学到的。感觉多做难题会学会很多知识点？按质因数状态做容斥也是在一个CF 3000分左右的题里面学到的。是不是应该考虑加大平时做题难度了呢。\nABC248G.GCD cost on the tree 一棵$N$个节点的树，点$i$的点权为$a[i]$。\n一条从$u$到$v$的路径权值被定义为路径上点权的GCD和路径点数的乘积。\n求这棵树所有路径的权值和。$N\\leq 10^5, a[i]\\leq 10^5$\n这种关于多个节点GCD相关的题目，一般来说可以考虑枚举公共约数$d$，这样抽出部分节点，直接求解。接下来做一步差分或者叫容斥。设公共约数为$d$的问题答案为$f(d)$，则最大公约数为$d$的问题答案为$g(d)=f(d)-\\sum_{i=2}^{i * d\\leq N}g(i*d)$。这一步复杂度为调和级数。\n对于这道题目也是一样的，假设约数为$d$的节点形成的森林$F$，对于这个$F$求出路径长度的和$f(d)$，然后求一下$g(d)$，最后$g(d)*d$加到答案上。\n复杂度的话，对于每个$a[i]$，约数最多大概是200个左右。那么所有森林的节点和为$200 * N$，配合8s的时限可以接受。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include \u0026lt;atcoder/modint\u0026gt; using modint = atcoder::modint998244353; int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); int mx = *std::max_element(a.begin(), a.end()); std::vector b(mx + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j * j \u0026lt;= a[i]; ++j) { if (a[i] % j) continue; b[j].push_back(i); if (a[i] / j != j) b[a[i] / j].push_back(i); } } std::vector G(mx + 1, std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;{}); for (int i = 1; i \u0026lt;= n - 1; ++i) { int u, v; read(u, v); int gcd = std::gcd(a[u], a[v]); for (int j = 1; j * j \u0026lt;= gcd; ++j) if (gcd % j == 0) { G[j].emplace_back(u, v); if (gcd / j != j) G[gcd / j].emplace_back(u, v); } } std::vector\u0026lt;modint\u0026gt; f(mx + 1); std::vector\u0026lt;int\u0026gt; size(n + 1); std::vector adj(n + 1, std::vector\u0026lt;int\u0026gt;{}); std::function\u0026lt;void(int, int)\u0026gt; dfs1 = [\u0026amp;](int u, int fa) { size[u]++; for (int v : adj[u]) if (v != fa) dfs1(v, u), size[u] += size[v]; }; std::function\u0026lt;modint(int, int, int)\u0026gt; dfs2 = [\u0026amp;](int u, int fa, int cnt) { modint res = 0; for (int v : adj[u]) if (v != fa) { res += 1ll * size[v] * (cnt - size[v]); res += dfs2(v, u, cnt); } return res; }; for (int j = 1; j \u0026lt;= mx; ++j) { if (b[j].size() == 0) continue; for (auto [u, v] : G[j]) adj[u].push_back(v), adj[v].push_back(u); for (int u : b[j]) if (size[u] == 0) { dfs1(u, 0); f[j] += 1ll * size[u] * (size[u] + 1) / 2; f[j] += dfs2(u, 0, size[u]); } for (int u : b[j]) size[u] = 0; for (auto [u, v] : G[j]) adj[u].clear(), adj[v].clear(); } modint ans = 0; for (int d = mx; d \u0026gt;= 1; --d) { for (int i = 2; i * d \u0026lt;= mx; ++i) f[d] -= f[i * d]; ans += f[d] * d; } ans -= std::accumulate(a.begin(), a.end(), modint(0)); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结一下：套路缝合怪。重点在于多个点的最大公约数，枚举公共约数然后做差分这一步。\nARC127D.Sum of Min of Xor 有两个长度为$N$的序列$A$和$B$。\n求$\\sum_{i=1}^{N} \\sum_{j=1}^{i-1} min(A_i \\oplus A_j, B_i \\oplus B_j)$\n$N\\leq 250000$\n$A[i] \u0026lt; 2^{18}, B[i] \u0026lt; 2^{18}$\n同一种技巧在CF1720D2。对于那道题目就是$a[i]\\oplus j \u0026gt; a[j] \\oplus i$。像这种交叉型的，考虑第一个出现差异的位。那么这一位之前都是相等的，就是说$a[i] \\oplus j = a[j] \\oplus i$，也就等价于$a[i] \\oplus i = a[j] \\oplus j$。于是这样就不交叉了。就可以在$a[j] \\oplus j$组成的Trie树里面操作了。当出现不同的位的时候分类讨论一下。\n对于这道题，在出现不同的位的时候，直接计算对应的异或和。相当于问题变成在一棵树的子树里面有一堆数字，求这堆数对$a[i]$的异或值的和。\n显然是经典问题，统计每一位01的数量即可。因此在$A[i] \\oplus B[i]$的Trie树上做这样的操作。当出现有差异的位时，去计算异或值的和。\n复杂度是$O(Nlog^2A)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 struct XORTrie { struct Info { std::array\u0026lt;int, 18\u0026gt; a_cnt{}, b_cnt{}; int tot = 0; }; struct node { std::array\u0026lt;int, 2\u0026gt; trans{}; int cnt; std::array\u0026lt;Info, 2\u0026gt; info{}; int \u0026amp;operator[](int i) { return trans[i]; } }; std::vector\u0026lt;node\u0026gt; trie; int n, cnt = 0; XORTrie(int _n) : n(_n), trie(std::min(1 \u0026lt;\u0026lt; 19, _n * 18) + 1) { } void insert(int a, int b) { int p = 0; int x = a ^ b; for (int i = 17; i \u0026gt;= 0; --i) { int bit = (x \u0026amp; (1 \u0026lt;\u0026lt; i)) \u0026gt; 0; if (!trie[p][bit]) trie[p][bit] = ++cnt; p = trie[p][bit]; bit = (a \u0026amp; (1 \u0026lt;\u0026lt; i)) \u0026gt; 0; for (int j = 0; j \u0026lt; i; ++j) { int abit = (a \u0026amp; (1 \u0026lt;\u0026lt; j)) \u0026gt; 0; int bbit = (b \u0026amp; (1 \u0026lt;\u0026lt; j)) \u0026gt; 0; trie[p].info[bit].a_cnt[j] += abit; trie[p].info[bit].b_cnt[j] += bbit; } trie[p].info[bit].tot++; } } ll query(int a, int b) { int c = a ^ b; int p = 0; ll res = 0; for (int i = 17; i \u0026gt;= 0; --i) { int abit = (a \u0026amp; (1 \u0026lt;\u0026lt; i)) \u0026gt; 0; int bbit = (b \u0026amp; (1 \u0026lt;\u0026lt; i)) \u0026gt; 0; int cbit = abit ^ bbit; if (int tmp = trie[p][cbit ^ 1]; tmp) { const Info \u0026amp;ainfo = trie[tmp].info[abit], \u0026amp;binfo = trie[tmp].info[abit ^ 1]; for (int j = 0; j \u0026lt; i; ++j) { int ajbit = (a \u0026amp; (1 \u0026lt;\u0026lt; j)) \u0026gt; 0; int bjbit = (b \u0026amp; (1 \u0026lt;\u0026lt; j)) \u0026gt; 0; if (ajbit) res += (1ll \u0026lt;\u0026lt; j) * (ainfo.tot - ainfo.a_cnt[j]); else res += (1ll \u0026lt;\u0026lt; j) * ainfo.a_cnt[j]; if (bjbit) res += (1ll \u0026lt;\u0026lt; j) * (binfo.tot - binfo.b_cnt[j]); else res += (1ll \u0026lt;\u0026lt; j) * binfo.b_cnt[j]; } } if (int nxt = trie[p][cbit]; nxt) { res += (1ll \u0026lt;\u0026lt; i) * trie[nxt].info[abit ^ 1].tot; p = nxt; } else break; } return res; } }; int Main() { int N; read(N); std::vector\u0026lt;int\u0026gt; A(N + 1), B(N + 1); std::for_each(A.begin() + 1, A.end(), read\u0026lt;decltype(A[0])\u0026gt;); std::for_each(B.begin() + 1, B.end(), read\u0026lt;decltype(B[0])\u0026gt;); XORTrie trie(N); ll ans = 0; for (int i = 1; i \u0026lt;= N; ++i) { ans += trie.query(A[i], B[i]); trie.insert(A[i], B[i]); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } 总结一下：思路上没啥问题，很自然。写起来分类讨论那段稍微有点费劲。\n然后遇到一个坑：正常插入一个高度为$H$的Trie树，可能会认为空间复杂度是$O(N * H)$。而这棵树其实最多有$2^{H+1}$个节点，不能盲目去开$O(N * H)$的空间。\n血泪史，有血有泪，还有屎\nARC180D.Division into 3 给一个长为$N$的序列$A$，每次查询给出一个区间$[L,R]$，需要把这个$[L,R]$分为三段，每段取最大值加起来求和，求这个最小的和是多少。一共$Q$次查询。\n$N \\leq 250000, Q \\leq 250000$\n首先这个三段中，整个区间$[l,r]$的最大值肯定在这里面。假设这三段为别是$L, M, R$。每段都不为空。\n假设最大值$mx$在$M$，那么显然$L$提供的值$max(L) \\geq a[l]$，$max(R) \\geq a[r]$。那么不如只取两边各一个元素。\n然后考虑$mx$在$L$中。假设位置是$p$。对于两段$M$和$R$，假设枚举$max(R)$，求出对应的最小的$M$。想象有一根线，从$r$开始向左滑动，发现对于这根线来说，最小的$M$其实就是线左边那个单独的元素。所以相当于是$a_i +max_{j=i+1}^{r}(a_j)$。发现后面那个值跟$r$有关。不妨扫描线这个$r$，更新这个值，这个过程就是单调栈。最终可以找到$a[r]$能作为最大值的那个区间$[k,r]$，则对于$[k,r-1]$中所有的$i$，$a[i]+a[r]$都是可选的值。懒标记线段树就可以更新这个值。接下来对于一个询问，最大值在$p$，查询$[p+1,r-1]$里的最小值和$a[p]$去更新答案。注意到如果最大值有多个，应该去最小的$p$而不是最大的$p$。因为这根线的滑动范围只有一个最小的限制，如果取最大的$p$，有的$M$和$R$就取不到了。\n对于$mx$在$R$里面，是镜像的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 int Main() { int n, q; read(n, q); std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; info(n + 1); std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { read(a[i]); info[i] = {a[i], i, i}; } struct Merge { std::array\u0026lt;int, 3\u0026gt; operator()(const std::array\u0026lt;int, 3\u0026gt; \u0026amp;lhs, const std::array\u0026lt;int, 3\u0026gt; \u0026amp;rhs) const { std::array\u0026lt;int, 3\u0026gt; res{}; if (lhs[0] == rhs[0]) res[0] = lhs[0], res[1] = lhs[1], res[2] = rhs[2]; else if (lhs[0] \u0026gt; rhs[0]) res = lhs; else res = rhs; return res; } }; SparseTable\u0026lt;std::array\u0026lt;int, 3\u0026gt;, Merge\u0026gt; st(info, n); std::vector\u0026lt;std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt;\u0026gt; qry(n + 1), invqry(n + 1); std::vector\u0026lt;int\u0026gt; ans(q + 1, std::numeric_limits\u0026lt;int\u0026gt;::max()); for (int i = 1; i \u0026lt;= q; ++i) { int l, r; read(l, r); auto [mx, _, __] = st.query(l, r); if (auto [mx1, _, __] = st.query(l + 1, r - 1); mx1 == mx) ans[i] = std::min(ans[i], mx + a[l] + a[r]); if (auto [mx1, L, R] = st.query(l, r - 2); mx1 == mx) qry[r].push_back({L + 1, i}); if (auto [mx1, L, R] = st.query(l + 2, r); mx1 == mx) invqry[n - l + 1].push_back({n - R + 2, i}); } auto solve = [\u0026amp;]() { std::stack\u0026lt;int\u0026gt; stack; std::vector\u0026lt;Info\u0026gt; init(n + 1); for (int i = 1; i \u0026lt;= n; ++i) init[i] = {a[i]}; LazySegmentTree\u0026lt;Info, Tag\u0026gt; segment_tree(init, n); a[0] = std::numeric_limits\u0026lt;int\u0026gt;::max(); stack.push(0); for (int r = 1; r \u0026lt;= n; ++r) { while (stack.size() \u0026amp;\u0026amp; a[stack.top()] \u0026lt;= a[r]) { int R = stack.top(); stack.pop(); int L = stack.top(); L = std::max(L, 1); if (L \u0026lt;= R - 1) segment_tree.apply(L, R - 1, {-a[R]}); } int pre = stack.top(); segment_tree.apply(std::max(pre, 1), r - 1, {a[r]}); stack.push(r); for (auto [l, i] : qry[r]) { auto [sum] = segment_tree.query(l, r - 1); ans[i] = std::min(ans[i], a[l - 1] + sum); } } }; solve(); std::reverse(a.begin() + 1, a.end()); qry = invqry; solve(); for (int i = 1; i \u0026lt;= q; ++i) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); return 0; } 总结一下：这个题其实做法很多的，也可以这样做：假设$f[i]$是$[i,r]$里划分两段的最大值的最小和，可以发现这两段要么是$[i,i][i+1,r]$，要么就是$[i,r-1][r,r]$。这样感觉维护一个$f[i]$然后用$a[r]$更新一下就行了。以及细节很多：首先$L,M,R$都是非空，那么最大值在$M$中，要用$[l+1,r-1]$的最大值和$[l,r]$的最大值比较一下，其它讨论是类似的。\n所以关键在于能识别出来讨论最大值到底在哪这一步，我做到了。但是后面的没太细琢磨，感觉做法很多有点乱。\n接着就是对于多个最大值到底选哪一个。我一直以为备选区间越短越好，但实际上我们只是能确定最大值一定在其中一个段（比如$L$里），剩下的实际上越长，备选越多，肯定不会错。假设是这种序列，$a+1,a+1,a+1,a,a+1,a+1,a+1$。如果多个最大值选了最大那个，剩下只有两个$a+1$，而实际上可以是$a$和$a+1$。这是我的一个坑点。\nABC212H.Nim Counting 一个简单的取石子游戏，每人选一堆石子取一个或多个，不能取的人输掉。\n现在有一个长度为$K$数组$A$，这个取石子游戏初始每一堆石子都得是$A$里面的一个数。对于所有不超过$N$堆石子的游戏，问先手必胜的游戏数量有多少。\n首先对于这种Nim游戏，先手必胜就是每堆石子$SG$函数的异或和不为0。由先验知识得到，最简单的这种取石子游戏$SG[i] = i$。那么题目问的就是不超过$N$个$A$中的数异或起来有多少种情况不为0。\n听起来挺OGF的。单堆石子的生成函数为$F(x)=\\sum_{i=1}^K(x^{A[i]})$。如果求的是加起来有多少种情况不为0，那么显然就是这个OGF的一个幂次。而这里是异或起来的情况不为0，相当于做异或卷积的幂次。\n即$\\sum_{i=1}^M([x^i]\\sum_{p=1}^N F(x)^{p})$。其中$M$是异或值域。\n位运算卷积考虑快速沃尔什变换。由于沃尔什变换是线性变换，那么首先\n$[x^i]FWT(\\sum_{p=1}^N F(x)^{p})=\\sum_{p=1}^N[x^i]FWT(F(x)^p)$；结果的第$i$项是OGF的幂次变换后第$i$项的和。\n又有$[x^i]FWT(F(x)^p)=([x^i]FWT(F(x)))^p$；OGF的$p$次幂变换后第$i$项等于OGF变换后第i项的$p$次幂。\n把两个式子搞到一块去就发现是\n$[x^i]FWT(\\sum_{p=1}^N F(x)^{p})=\\sum_{p=1}^N([x^i]FWT(F(x)))^p=\\frac{F[i](1 - F[i]^{N+1})}{1-F[i]}$等比数列求和。\n这样得到了沃尔什变换后的多项式，逆变换回去就可以了。\n时间复杂度$O((K+M)log_2M+Mlog_2N)$。其中$M$是异或值域。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 using modint = atcoder::modint998244353; using FWT = FastWalshHadamardTransform\u0026lt;modint, std::__bitwise_xor\u0026gt;; int Main() { int n, k; read(n, k); std::vector\u0026lt;int\u0026gt; a(k + 1); for (int i = 1; i \u0026lt;= k; ++i) read(a[i]); int mx = *std::max_element(a.begin(), a.end()); int bits = std::log2(mx) + 1; mx = 1 \u0026lt;\u0026lt; bits; std::vector\u0026lt;modint\u0026gt; f(mx); for (int i = 1; i \u0026lt;= k; ++i) f[a[i]] += 1; FWT::dft(f); for (int i = 0; i \u0026lt; mx; ++i) { if (f[i] == 1) f[i] = n; else f[i] = (f[i] - f[i].pow(n + 1)) / (modint{1} - f[i]); } FWT::idft(f); modint ans = std::accumulate(f.begin() + 1, f.end(), modint(0)); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结：新知识点：快速沃尔什变换；FFT和FWT是线性变换，绝大部分的题目，要用到这一点：先按FWT变换之后的线性性质，变成点乘或者点加，再把结果IFWT回去。\nABC367G.Sum of (XOR^K or 0) 在一个长度为$N$的数组$A$中，选择一些非空子序列，这些子序列的长度都是$M$的倍数。\n一个子序列的价值为子序列异或和的$K$次幂。求所有合法子序列的价值和。$N,K\\leq 2\\times10^5,M\\leq100,A[i]\u0026lt;2^{20}$。\n先考虑没有$M$的倍数这一限制怎么做。显然拿到每个异或和的出现次数，问题就迎刃而解。\n可以用OGF来刻画取子序列的过程：$\\prod_{i=1}^N(1+x^{A[i]})$，乘法为异或卷积。注意去除空序列。\n那么如何快速计算这个OGF的连乘？\n注意到$x^{A[i]}$的系数恒为1，由于异或卷积的性质，$(1+x^{A[i]})$在FWT之后的式子中，对于每一项$p$，要么提供$(1+1)$的系数，要么提供$(1-1)$的系数。\n单独拿来一个项$p$，有若干个$i$提供了2的系数，有若干个$i$提供了0的系数，假设两者$i$的数量分别为$c_0,c_1$。那么显然$c_0+c_1=n$。我们要求的点乘之后的系数就是$2^{c_0}$。\n现在根据点加，$FWT(\\sum_{i=1}^N(1+x^{A[i]}))=\\sum_{i=1}^N FWT(1+x^{A[i]})$。对于第$p$项，显然FWT点加之后的系数是$2c_0$。这样算一下$FWT(\\sum_{i=1}^N(1+x^{A[i]}))$就求解了每一项$p$的$c_0$，进而能得到点乘式的系数。\n回到原问题，由于要考虑子序列长度的限制，设一个二元普通生成函数$F_i(x,y)=(1+x^{A[i]}y)$。\n这样求解的就是$\\prod_{i=1}^N(1+x^{A[i]}y)$，其中在$x$这一维做异或卷积，在$y$这一维做加法取模卷积。最终要找这个式子中所有$x^py^0$的系数。\n依然用上述思路考虑。\n$(1+x^{A[i]}y)$在FWT之后的式子中，对于每一项$p$，要么提供$(1+y)$的系数，要么提供$(1-y)$的系数。同样设前者的$i$有$c_0$个，后者有$c_1$个。\n而由点加，$y$前面的系数就是$c_0-c_1$。于是点乘式可以写成$(1+y)^{c_0}(1-y)^{n-c_0}$。\n对于加法取模卷积，注意到只有不超过100项。那么可以用背包DP预处理$(1+y)^i$和$(1-y)^i$。最终对每个$(1+y)^i(1-y)^{n-i}$单独求一下$y^0$的系数$y0[i]$，即可全部预处理。然后做FWT，对每一项$p$求解$c_0$，拿到$y0[c_0]$，$y^0$这一维的点乘式$F\u0026rsquo;$的系数；最终所求就是$F=FWT(F\u0026rsquo;)$\n枚举每一项，按答案所求加个权就行了。注意没有空序列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 int Main() { int N, M, K; read(N, M, K); std::vector\u0026lt;int\u0026gt; a(N + 1); for (int i = 1; i \u0026lt;= N; ++i) read(a[i]); std::array\u0026lt;std::vector\u0026lt;std::vector\u0026lt;modint\u0026gt;\u0026gt;, 2\u0026gt; dp{}; dp.fill(std::vector(N + 1, std::vector\u0026lt;modint\u0026gt;(M))); dp[0][0][0] = dp[1][0][0] = 1; for (int k = 0, p = mod - 1; k \u0026lt; 2; ++k) { p = 1ll * p * (mod - 1) % mod; // printf(\u0026#34;%d\\n\u0026#34;, p); for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 0; j \u0026lt; M; ++j) dp[k][i][j] = dp[k][i - 1][j] + dp[k][i - 1][(j - 1 + M) % M] * p; } } std::vector\u0026lt;modint\u0026gt; y0(N + 1); for (int i = 0; i \u0026lt;= N; ++i) { //(1 + y) ^ i * (1 - y) ^ (N - i) for (int j = 0; j \u0026lt; M; ++j) y0[i] += dp[0][i][j] * dp[1][N - i][(M - j) % M]; } //(1 + x ^ a[i] * y) constexpr int B = 20; std::vector\u0026lt;int\u0026gt; diff(1 \u0026lt;\u0026lt; B); for (int i = 1; i \u0026lt;= N; ++i) diff[a[i]]++; FWTXor\u0026lt;int\u0026gt;::dft(diff); std::vector\u0026lt;modint\u0026gt; f(1 \u0026lt;\u0026lt; B); for (int i = 0; i \u0026lt; diff.size(); ++i) { // a + b = n, a - b = diff[i] int x = (N + diff[i]) / 2; f[i] = y0[x]; } FWTXor\u0026lt;modint\u0026gt;::idft(f); f[0] -= 1; modint ans = 0; for (int i = 0; i \u0026lt; f.size(); ++i) ans += f[i] * modint{i}.pow(K); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结：把上一题的技巧扩展到二元，同样求解方程式。思路依然可以先易后难，递进式思考。对于二元卷积，相当于第一维卷积之后再对另一维卷积，多元同理。\nARC165E.Random Isolation 有一棵$N$个节点的树。\n每次随机选一个大于$K$个节点的连通块中的某一个节点，删掉这个节点及相连的边，直到没有可以选中的节点为止。\n求这个操作数的期望。\n$N\\leq 100$\n首先多个点，每个点只操作一次；设$X_i$表示$i$节点的操作数，显然$X_i={0或1}$。要求的就是$E(\\sum_{i=1}^NX_i)$。由期望的线性性，这个式子等价于$\\sum_{i=1}^NE(X_i)$。这样就把贡献单独拆到每个点上了。\n由于有的节点可以选有的节点可以不选，那么对于每个节点它被选中的概率是不方便计算的。\n有一个套路是假想存在一个排列$P$，按照$P$的顺序来操作，如果遇到了不合法的节点就跳过。这样和原问题是等价的。\n至于原因可以这样考虑。\n不考虑不合法的节点，假设局面当前局面是$s$，后续合法决策有$m$个，每个决策对应的新局面是$t_i$。\n这样局面$s$的操作期望就是$E(s)=\\sum_{i=1}^m\\frac{1}{m}E(t_i)+1$。\n那么当考虑了不合法操作之后，假设有$n$个不合法操作，因为不合法操作不改变当前局面所以是\n$E(s)=\\frac{n}{n+m}E(s)+\\sum_{i=1}^m\\frac{1}{n+m}E(t_i)+\\frac{m}{n+m}$。\n移项之后会发现是一样的。\n所以这样做是等价的。\n那么这样考虑在一个排列里面为什么$P_i$这个数会带来贡献。当且仅当$P_i$这个数所在的连通块的大小超过$k$。假设这个连通块大小为$s$；那么之所以出现了这个$s$大小的连通块，一定是前面删去了若干个和这个连通块相连的若干点设为$d$。所以一个大小为$s$的连通块，缩点之后如果度数为$d$，这个连通块的在排列中出现的概率是$\\frac{d!s!}{(d+s)!}$，因为先要出现$d$个被删的点在前面，然后后面再出现$s$个本连通块里的点，所以对期望的贡献也是$\\frac{d!s!}{(d+s)!}$。因此只要统计这个$(s,d)$类型的连通块的数量就行。\n这就转化到树上DP了。树上背包做转移就行。\n这里还涉及到一个树上背包按子树$size$做背包容量的复杂度计算。\n假设树上背包，节点$u$的前$i$个节点，考虑$s$个节点的背包方程$f[u][i][s]$，枚举子树$v$的容量$t$做转移的时候，$f[u][i][s]=merge(f[u][i-1][s-t],dp[v][t])$。这里面首先要枚举一个$i$，$s$和$t$，看起来是$O(n^3)$的复杂度。但实际上$s$枚举大小如果按点$u$已知的$size$实时更新，复杂度是$O(n^2)$。\n大概是这样写\n1 2 3 4 5 6 7 8 9 size[u] = 1; for (int i = 1; i \u0026lt;= adj[u].size(); ++i) { int v = adj[u][i-1]; for (int s = 1; s \u0026lt;= size[u]; ++s) for (int t = 1; t \u0026lt;= size[v];++t) f[u][i][s+t] = merge(f[u][i-1][s],dp[v][t]); size[u]+=size[v]; } 至于原因。可以这样想象。每次子树$v$合并的时候，是向前$i-1$个子树里面所有节点合并，等价于把子树$v$里面的节点和前$i-1$个子树的里面的节点配对做节点对，每个节点向dfs序在自己前面的节点配对，最终能配出$O(n^2)$个节点对，因此总复杂度是$O(n^2)$。\n那么这样整个复杂度就是$O(N^4)$，完全可以通过，甚至跑的相当快。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 int Main() { int n, k; read(n, k); std::vector adj(n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt; n; ++i) { int u, v; read(u, v); adj[u].push_back(v), adj[v].push_back(u); } std::vector dp(n + 1, std::vector(n + 1, std::vector\u0026lt;modint\u0026gt;(n + 1))); std::vector size(n + 1, 1); auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u, int fa) -\u0026gt; void { if (fa != 0) adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa)); for (int v : adj[u]) self(self, v, u); std::vector f(adj[u].size() + 1, std::vector(n + 1, std::vector\u0026lt;modint\u0026gt;(n + 1))); f[0][1][0] = 1; for (int i = 1; i \u0026lt;= adj[u].size(); ++i) { int v = adj[u][i - 1]; for (int s = 1; s \u0026lt;= size[u]; ++s) for (int d = 1; d \u0026lt;= size[u]; ++d) f[i][s][d] = f[i - 1][s][d - 1]; for (int s = 1; s \u0026lt;= size[u]; ++s) for (int t = 1; t \u0026lt;= size[v]; ++t) { for (int d = 0; d \u0026lt;= size[u]; ++d) for (int c = 0; c \u0026lt;= size[v]; ++c) f[i][s + t][d + c] += f[i - 1][s][d] * dp[v][t][c]; } size[u] += size[v]; } for (int s = 1; s \u0026lt;= size[u]; ++s) for (int d = 0; d \u0026lt;= size[u]; ++d) dp[u][s][d] += f[adj[u].size()][s][d]; // for (int s = 1; s \u0026lt;= size[u]; ++s) // for (int d = 0; d \u0026lt;= size[u]; ++d) // { // printf(\u0026#34;dp[%d][%d][%d] = %d\\n\u0026#34;, u, s, d, dp[u][s][d]); // } }; dfs(dfs, 1, 0); Combinatorics\u0026lt;modint\u0026gt; combinatorics(n); modint ans = 0; for (int i = 1; i \u0026lt;= n; ++i) for (int s = k + 1; s \u0026lt;= size[i]; ++s) for (int d = 0; d \u0026lt;= size[i]; ++d) { if (dp[i][s][d] != 0) ans += dp[i][s][d] * combinatorics.fac[s] * combinatorics.fac[d + (i != 1)] * combinatorics.invfac[s + d + (i != 1)]; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结：新技巧get！按局面算期望，生成操作排列，这样把整体的概率计算转移到了局部上，进行分析之后再DP。适合经过几轮操作之后，有的操作合法有的操作不合法的期望计算。\nARC150D.Removing Gacha 有一棵$N$个节点的树，树上节点一开始是白色。\n如果一个节点$i$到1的路径上全是黑色的点，那么这个点是好点；否则是坏点\n现在每次随机地从坏点中选一个点来染成黑色。问把整棵树都染黑的期望数。\n$N\\leq2\\times10^5$\n相比于上面那道题，这道题相当于取完球之后放回，操作序列是无穷长度的。\n同样考虑一个操作序列，首先点$i$产生贡献当且仅当$1-\u0026gt;i$的路径上所有点没出现全。这样在这个序列里我们只关心这条路径。\n设$i$的深度为$dep_i$。\n那么相当于有放回地取$dep_i$个球，直到所有球都取了一遍，选中$i$的期望次数。\n可以写出一个DP。一般期望DP是倒推的。\n假设有$n$个球，设$dp[x]$表示已经抽取了$x$个球，还需要的操作次数期望。显然$dp[n]=0$。\n这样就有$dp[x]=\\frac{x}{n}dp[x]+\\frac{n-x}{n}dp[x+1]+1$。前者表示取到了一个已经取过的球，局面不变，后者表示取到没取过的球局面改变，每次操作带来1的贡献。最终要的就是$dp[0]$\n然而这里我们想要的是取到了$n$号球的次数期望值。做一些修改\n$dp[x]=\\frac{x}{n}dp[x]+\\frac{n-x}{n}dp[x+1]+\\frac{1}{n}$。有$\\frac{1}{n}$的概率产生1的操作次数贡献。\n推一下发现就是$dp[x]=dp[x+1]+\\frac{1}{n-x}$。\n那么$dp[0]=\\sum_{x=1}^{n}\\frac{1}{x}$。\n所以点$i$的操作期望就是$\\sum_{x=1}^{dep_i}\\frac{1}{x}$。求一个和就行了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 2; i \u0026lt;= n; ++i) read(p[i]); Combinatorics\u0026lt;modint\u0026gt; combinatorics(n); std::vector\u0026lt;modint\u0026gt; sum(n + 1); for (int i = 1; i \u0026lt;= n; ++i) sum[i] = sum[i - 1] + combinatorics.inv[i]; std::vector\u0026lt;int\u0026gt; dep(n + 1); modint ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { dep[i] = dep[p[i]] + 1; ans += sum[dep[i]]; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结：类似题目好像CF也有一道。那个题是这样的：每次找一个白点染色，把整棵子树染黑。求操作次数期望。考虑生成一个操作序列$P$，点$P_i$提供价值当且仅当$P_i$的祖先们都在$i$后面，概率为$\\frac{1}{dep_i}$。\n而这道题首先是有放回地取数，操作序列是无穷的。其次我们同样只需要考虑点$i$的路径，因为只有这样才对点$i$的答案造成影响。通过一个简单的期望DP推出公式。\n期望DP一般都是逆推，因为终止局面的期望值是最好计算的。\nARC185D.Random Walk on Tree 有$N*M+1$个节点，下标从0开始。点$i$连接到$max(i-N,0)$。\n现在从点0出发，问第一次走到所有点的期望。\n$N,M \\leq 200000$\n把图画出来就是一个0点下面挂了$N$个长度为$M$的串。显然每一个串需要走到第$M$个数才能走完所有点。那么走完所有点等价于走完了所有串的末尾，且对于位于0点所处的局面，只有走到一个串的末尾才能改变，因此我们只关注目前访问的串末尾的数量\n设$dp[i]$表示访问了$i$个不相同的末尾，目前在0点仍需要访问的串末尾数，有$dp[N]=0$。\n那么有$dp[i]=\\frac{N-i}{N}dp[i+1]+\\frac{i}{N}dp[i]+1$。\n在访问一个末尾的时候，局面是独立且相同的，考虑一段操作序列，只在最后出现访问到末尾并走回0。那么前面的所有操作，这些不影响局面的无效操作都可以看做是跟最后那段访问到末尾是同一个串上的操作——因为前面的无效操作所属的串是无关紧要的，于是访问到一个串的末尾的操作期望次数等价于在独立的一个串上走到末尾的操作期望。\n这可以看做是一个简单的路径图上的随机游走问题。\n设$E(X_i)$表示从$i$第一次走到$i+1$的期望次数。\n那么有$E(X_i)=\\frac{1}{2}+\\frac{1}{2}(1+E(X_{i-1}+E(X_i))=E(X_{i-1})+2$，有$E(0)=1$。\n于是第一次从0走到$M$的期望就是$\\sum_{i=0}^{M-1}E(i)$，答案是$M^2$.走过去再回来相当于两次随机游走，因此是$2M^2$。\n$$dp[0] * 2M^2-M^2$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Main() { int n, m; read(n, m); Combinatorics\u0026lt;modint\u0026gt; combinatorics(n); modint ans = 0; for (int i = 1; i \u0026lt;= n; ++i) ans += combinatorics.inv[i]; ans *= 2 * n; ans *= 1ll * m * m; ans -= 1ll * m * m; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 总结一下：\n第一个重点在于分清楚图的样子；\n第二个重点是，即便是多个串，走到任意一个串的末尾的期望步数等价于只有一个串走到末尾的期望步数。这是因为刨去最后走到末尾的步数序列，前面的操作是无效且不改变局面的，那么这段操作访问的串的编号无关紧要，因为存在$N$种长度为$L$的无效操作（只换编号那种），每种概率是$\\frac{1}{N}$，乘起来是1，等价于只有一种编号。\n第三个重点是随机游走问题，这也是卡了我很久的地方。这部分局面考虑的是一条边的局面，而不是点的局面，图上的随机游走问题考察的局面是边。同样这也是考虑有效操作——走一条$x-\u0026gt;y$的路径，访问的边是$p_1,p_2,\u0026hellip;,p_k$，只有$p_i$是有效的，其它操作不改变局面。\nAGC002D.Stamp Rally 单个询问满足二分性，但是为了在二分的过程中判断答案$mid$是否合法，需要维护一个前$mid$个节点组成的并查集。而当并查集已知的时候判断单个询问是否合法是$O(1)$的。\n这里如果使用可持久化并查集就可以在线回答问题。\n而将询问离线，使用整体二分就可以在分治的时候维护并查集，快速对大量询问进行判定。\n时间复杂度$O((n+q)log_2 n)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 struct CancelableDSU { public: CancelableDSU() : n(0) {} explicit CancelableDSU(int _n) : n(_n), parent_or_size(_n + 1, -1) {} int merge(int a, int b) { int x = leader(a), y = leader(b); if (-parent_or_size[x] \u0026lt; -parent_or_size[y]) std::swap(x, y); h.push_back({x, y, parent_or_size[x], parent_or_size[y]}); if (x == y) return x; parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x; return x; } std::array\u0026lt;int, 4\u0026gt; cancel() { auto [x, y, sx, sy] = h.back(); h.pop_back(); parent_or_size[y] = sy; parent_or_size[x] = sx; return {x, y, sx, sy}; } bool same(int a, int b) { return leader(a) == leader(b); } int leader(int a) { if (parent_or_size[a] \u0026lt; 0) return a; return leader(parent_or_size[a]); } int size(int a) { return -parent_or_size[leader(a)]; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; groups() { std::vector\u0026lt;int\u0026gt; leader_buf(n + 1), group_size(n + 1); for (int i = 1; i \u0026lt;= n; i++) { leader_buf[i] = leader(i); group_size[leader_buf[i]]++; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result(n); for (int i = 1; i \u0026lt;= n; i++) { result[i].reserve(group_size[i]); } for (int i = 1; i \u0026lt;= n; i++) { result[leader_buf[i]].push_back(i); } result.erase( std::remove_if(result.begin(), result.end(), [\u0026amp;](const std::vector\u0026lt;int\u0026gt; \u0026amp;v) { return v.empty(); }), result.end()); return result; } private: int n; // root node: -1 * component size // otherwise: parent std::vector\u0026lt;std::array\u0026lt;int, 4\u0026gt;\u0026gt; h; std::vector\u0026lt;int\u0026gt; parent_or_size; }; int Main() { int N, M; read(N, M); std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; edges(M + 1); for (int i = 1; i \u0026lt;= M; ++i) { auto \u0026amp;[u, v] = edges[i]; read(u, v); } int Q; read(Q); std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; qry(Q + 1); for (int i = 1; i \u0026lt;= Q; ++i) { auto \u0026amp;[x, y, z] = qry[i]; read(x, y, z); } std::vector\u0026lt;int\u0026gt; ans(Q + 1); CancelableDSU dsu(N); std::function\u0026lt;void(int, int, const std::vector\u0026lt;int\u0026gt; \u0026amp;)\u0026gt; solve = [\u0026amp;](int l, int r, const std::vector\u0026lt;int\u0026gt; \u0026amp;q) { if (l == r) { for (int i : q) ans[i] = l; auto [u, v] = edges[l]; dsu.merge(u, v); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; for (int i = l; i \u0026lt;= mid; ++i) { auto [u, v] = edges[i]; dsu.merge(u, v); } std::vector\u0026lt;int\u0026gt; ql, qr; for (int i : q) { auto [x, y, z] = qry[i]; int size = dsu.size(x); if (!dsu.same(x, y)) size += dsu.size(y); if (size \u0026lt; z) qr.push_back(i); else ql.push_back(i); } for (int i = l; i \u0026lt;= mid; ++i) dsu.cancel(); solve(l, mid, ql); solve(mid + 1, r, qr); }; std::vector\u0026lt;int\u0026gt; q(Q + 1); for (int i = 1; i \u0026lt;= Q; ++i) q[i] = i; solve(1, M, q); for (int i = 1; i \u0026lt;= Q; ++i) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); return 0; } ARC185E.Adjacent GCD 累了，做个水题。\n","date":"2024-10-21T13:49:33+08:00","permalink":"https://rafakang.github.io/p/atcoder%E6%B3%9B%E5%81%9A/","title":"Atcoder泛做"},{"content":"A 题目链接\n直接按题意模拟即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Main() { int N, C; std::cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; C; std::vector\u0026lt;int\u0026gt; T(N + 1); for (int i = 1; i \u0026lt;= N; ++i) std::cin \u0026gt;\u0026gt; T[i]; int last = -1e9, ans = 0; for (int i = 1; i \u0026lt;= N; ++i) if (T[i] - last \u0026gt;= C) ++ans, last = T[i]; std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } B 题目链接\n以左手为例。假设当前位置是$l$，要去的位置是$t$。\n实际上只有两种走过去的方式——顺时针和逆时针。\n如果顺时针走先碰到右手的位置$r$，那么只能逆时针走。等价于顺时针走$l$到$r$的距离小于$l$到$t$的距离。\n于是我们写一个函数求从$a$走到$b$，按逆时针和顺时针的距离即可。\n以顺时针为例，距离的求法是$b-a(b\u0026gt;a);n+b-a(b\u0026lt;a)$。或者统一一下，直接写$(n+b-a)\\bmod n$。\n逆时针走就是用$n$减去顺时针走的距离。\n那么这道题就解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int dist(int n, int a, int b, int d) { if (d == 1) return (n + (b - a)) % n; else return (n - (n + (b - a)) % n) % n; }; int Main() { int n, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; int l = 1, r = 2; int ans = 0; for (int i = 1; i \u0026lt;= q; ++i) { std::string h; int t; std::cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; t; if (h == \u0026#34;L\u0026#34;) { if (dist(n, l, t, 1) \u0026gt;= dist(n, l, r, 1)) ans += dist(n, l, t, -1); else ans += dist(n, l, t, 1); l = t; } else { if (dist(n, r, t, 1) \u0026gt;= dist(n, r, l, 1)) ans += dist(n, r, t, -1); else ans += dist(n, r, t, 1); r = t; } // std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } C 题目链接\n如果有N个箱子和N个玩具，想每个玩具都放进去的话，那么一定是排序之后，$a[i]\\leq b[i]$。\n考虑现在少一个箱子，那么可以在出现$a[i]\u0026gt;b[i]$的时候，买一个$a[i]$大小的箱子就行。\n这里可以使用双指针，一个指针$i$指向$a$数组，第二个指针$j$指向$b$数组。如果出现$j\u0026lt;i$且装不下的情况，就无解。因为这时已经买了一个箱子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int Main() { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;int\u0026gt; a(n + 1), b(n); for (int i = 1; i \u0026lt;= n; ++i) std::cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt;= n - 1; ++i) std::cin \u0026gt;\u0026gt; b[i]; std::sort(a.begin() + 1, a.end(), std::greater\u0026lt;int\u0026gt;{}); std::sort(b.begin() + 1, b.end(), std::greater\u0026lt;int\u0026gt;{}); b.push_back(0); int ans = 0; for (int i = 1, j = 1; i \u0026lt;= n; ++i) { if (a[i] \u0026lt;= b[j]) { j++; continue; } else if (std::abs(j - i) == 1) return printf(\u0026#34;-1\\n\u0026#34;), 0; else ans = a[i]; } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } D 题目链接\n找到通向$1$的最小环，等价于有向图上找从$1$开始到$1$的前继的点的最短路。由于图没有边权，因此使用bfs即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int Main() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector adj(n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt;= m; ++i) { int u, v; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); } std::queue\u0026lt;int\u0026gt; q; q.push(1); std::vector\u0026lt;int\u0026gt; dist(n + 1, 1e9); dist[1] = 0; while (q.size()) { int u = q.front(); q.pop(); for (int v : adj[u]) { if (v == 1) return printf(\u0026#34;%d\\n\u0026#34;, dist[u] + 1), 0; if (dist[v] \u0026gt; dist[u] + 1) dist[v] = dist[u] + 1, q.push(v); } } printf(\u0026#34;-1\\n\u0026#34;); return 0; } E 题目链接\n这种两个元素组合起来求一个最小值或者最大值的题，一般的解决方法是枚举其中一个元素，然后以枚举到的值为限制，求另一个值的最小值。\n以这道题为例，可以枚举$max(A[i])$。那么我们发现，能加入到子序列中的都是比$A[i]$小的值。\n相当于把两个数组都按$A[i]$排序之后，取$A[i]$为最大值，然后在$A[1]\u0026hellip;A[i-1]$里找到$K-1$个数使得$B$数组的和最小。\n显然找到找到最小的$K-1$个$B$数组里的数就行。那么维护一个大小为$K-1$的set或者堆即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 int Main() { int N, K; std::cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; std::vector\u0026lt;int\u0026gt; A(N + 1), B(N + 1); for (int i = 1; i \u0026lt;= N; i++) { std::cin \u0026gt;\u0026gt; A[i]; } for (int i = 1; i \u0026lt;= N; i++) { std::cin \u0026gt;\u0026gt; B[i]; } ll ans = 1e18; std::vector\u0026lt;int\u0026gt; ord(N + 1); for (int i = 1; i \u0026lt;= N; ++i) ord[i] = i; std::sort(ord.begin() + 1, ord.end(), [\u0026amp;](int i, int j) { return A[i] \u0026lt; A[j]; }); std::priority_queue\u0026lt;int\u0026gt; pq; ll sum = 0; for (int p = 1; p \u0026lt;= N; ++p) { int i = ord[p]; sum += B[i]; pq.push(B[i]); while (pq.size() \u0026gt; K) { sum -= pq.top(); pq.pop(); } if (pq.size() == K) ans = std::min(ans, sum * A[i]); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } F 题目链接\n可以考虑一个dp。\n$dp[i][j]$表示前$i$个查询之后，另一只手在$j$位置的最小操作数。然而这里“另一只手”的描述稍微有点不利于转移。\n注意到每次操作之后都有某一只手的位置是固定的，现在未知的就是另一只手的位置，我们的枚举也是另一只手。为了方便明确状态和转移，这里不妨以两只手的某种关系来做状态的第二维。\n例如：两只手位置的和、两只手位置的差、两只手位置的乘积等等。\n这里选择两只手位置的和$s$来做状态的第二维。那么只需要根据上一个操作即可解出目前两只手的位置。注意规避两只手位置相同，或者小于等于$0$的情况。\n其实更好的状态可以选择枚举两只手位置的异或值。这样只要我们不从$0$开始枚举，那么能规避两只手位置是负数以及相同的情况，可以少写一些判断。\n接下来考虑$dp[i][s]$。前i个查询之后，目前两只手位置和为$s$的最小操作数。\n我们在思考转移的时候，感觉前一个状态不太好找。那么不妨考虑顺推。用$dp[i][s]$去推$dp[i+1][s\u0026rsquo;]$。\n现在我们知道$i$查询之后的左右手的值$l, r$。\n以及$i+1$查询，某一只手的目的地$t$。假设是左手。\n根据B题的结论，我们依旧是两种决策——从顺时针走和逆时针走。\n如果从顺时针走先碰到了右手，那么右手的最终位置是$(t+1) \\bmod n$。\n从逆时针走先碰到右手，右手的最终位置是$(t-1) \\bmod n$。\n用B题的距离函数判断一下并计算转移即可。\n这样题目就解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 int Main() { int n, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; op(q + 1); for (int i = 1; i \u0026lt;= q; ++i) { std::string h; std::cin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; op[i][1]; op[i][0] = (h == \u0026#34;R\u0026#34;); } std::vector dp(q + 1, std::vector\u0026lt;int\u0026gt;(n * 2 + 1, 1e9)); dp[0][3] = 0; op[0] = {0, 1}; auto dist = [\u0026amp;](int a, int b, int d) { if (d == 1) return (n + (b - a)) % n; else return (n - (n + (b - a)) % n) % n; }; for (int i = 0; i \u0026lt; q; ++i) { for (int s = 2; s \u0026lt;= n + n; ++s) { if (dp[i][s] \u0026gt; 2 * q * n) continue; int l = (op[i][0] == 0) ? op[i][1] : (s - op[i][1]); int r = (op[i][0] == 1) ? op[i][1] : (s - op[i][1]); if (l \u0026lt;= 0 || r \u0026lt;= 0 || l == r) continue; if (op[i + 1][0] == 1) std::swap(l, r); // printf(\u0026#34;dp[%d][%d][%d] = %d\\n\u0026#34;, i, l, r, dp[i][s]); int L = op[i + 1][1]; if (dist(l, L, -1) \u0026gt;= dist(l, r, -1)) { int R = (L - 1) % n; if (R == 0) R = n; dp[i + 1][L + R] = std::min(dp[i + 1][L + R], dist(l, L, -1) + dist(r, R, -1) + dp[i][s]); } if (dist(l, L, -1) \u0026lt; dist(l, r, -1)) { dp[i + 1][L + r] = std::min(dp[i + 1][L + r], dist(l, L, -1) + dp[i][s]); } if (dist(l, L, 1) \u0026gt;= dist(l, r, 1)) { int R = (L + 1) % n; if (R == 0) R = n; dp[i + 1][L + R] = std::min(dp[i + 1][L + R], dist(l, L, 1) + dist(r, R, 1) + dp[i][s]); } if (dist(l, L, 1) \u0026lt; dist(l, r, 1)) dp[i + 1][L + r] = std::min(dp[i + 1][L + r], dist(l, L, 1) + dp[i][s]); } } int ans = *std::min_element(dp[q].begin(), dp[q].end()); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } G 题目链接\n一道数学期望的题目。\n假设有一个探测排列$q$。我们来分析一下这个$q$有什么性质。\n$q[i]$在第$i$次被探测到，那么相当于$q[i]$的父亲在$i$之前被探测到了。\n也就是说，$q$中节点的顺序，应该保证$q[i]$的父亲在$q[i]$之前出现。\n然后考虑这个排列$q$的操作期望。设$sum$是$a$的总和。\n如果财宝在$q[i]$位置，那么有$\\frac{a[q[i]]}{sum}$的概率在$q[i]$停止探测。\n$$E(q)=\\sum_{i=1}^n \\frac{i*a[q[i]]}{sum}$$注意到$sum$是一个定值。那么最小期望操作次数的排列$q$，满足$\\sum_{i=1}^n i*a[q[i]]$是最小的。\n整理一下，最佳的排列$q$，需要满足两个条件：\n1.$q$中节点的顺序，应该保证$q[i]$的父亲在$q[i]$之前出现\n2.$\\sum_{i=1}^n i*a[q[i]]$是最小的\n这个问题叫做按树上先序的贪心。\n原题是2018年湖南省队的题目排列。\n贪心的idea可能比较反直觉。\n假设没有树上的父亲要在前面这个条件，根据排序不等式，显然是把$a[i]$按降序排序能得到最小值。\n那么考虑当前最大的$a[i]$。\n如果$a[i]$的父亲是$0$，那么可以直接搜点$i$。\n如果$a[i]$有其它的父亲，那么一定是搜完了父亲之后，直接来搜$i$。\n第二句话等价于在最优排列中，$i$的父亲和$i$一定是挨着的。\n因此我们可以考虑把$i$和$i$的父亲合并起来，因为他们俩必定是挨在一起出现。\n于是若干操作之后，要比较的是多个合并后的节点。\n那么合并之后的节点需要怎么计算权重呢？\n根据题目限制的条件，假设两个合并之后的节点$x$和$y$，分别代表两个必须要挨在一起的序列。\n节点x的序列长度为$c_1$，序列权重和为$s_1$，这个序列的答案$(\\sum i*a[i])$是$ans_1$。节点y的序列长度为$c2$，序列权重和为$s2$，序列的答案是$ans_2$。\n如果$x$在$y$之前，相当于为答案提供的贡献是$ans_1+ans_2+c_1* s_2$。反之，为答案提供的贡献是$ans_2+ans_1+c_2*s_1$。\n如果$x$在$y$之前更好，把这两个式子做一个差，等价于$\\frac{s_1}{c_1}\u0026gt;\\frac{s_2}{c_2}$;相当于合并之后的节点，权重是平均值。\n用堆维护当前节点的权重大小，用并查集维护节点之间的合并关系，这道题就解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include \u0026lt;atcoder/modint\u0026gt; using modint = atcoder::modint998244353; struct DSU { public: DSU() : n(0) {} explicit DSU(int _n) : n(_n), parent_or_size(_n + 1, -1) {} int merge(int a, int b) { int x = leader(a), y = leader(b); if (x == y) return x; parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x; return x; } bool same(int a, int b) { return leader(a) == leader(b); } int leader(int a) { if (parent_or_size[a] \u0026lt; 0) return a; return parent_or_size[a] = leader(parent_or_size[a]); } int size(int a) { return -parent_or_size[leader(a)]; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; groups() { std::vector\u0026lt;int\u0026gt; leader_buf(n + 1), group_size(n + 1); for (int i = 1; i \u0026lt;= n; i++) { leader_buf[i] = leader(i); group_size[leader_buf[i]]++; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result(n); for (int i = 1; i \u0026lt;= n; i++) { result[i].reserve(group_size[i]); } for (int i = 1; i \u0026lt;= n; i++) { result[leader_buf[i]].push_back(i); } result.erase( std::remove_if(result.begin(), result.end(), [\u0026amp;](const std::vector\u0026lt;int\u0026gt; \u0026amp;v) { return v.empty(); }), result.end()); return result; } private: int n; // root node: -1 * component size // otherwise: parent std::vector\u0026lt;int\u0026gt; parent_or_size; }; int Main() { int n; read(n); std::vector\u0026lt;int\u0026gt; a(n + 1); std::vector\u0026lt;int\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(p[i]); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); p[0] = -1; struct comp { bool operator()(const std::array\u0026lt;int, 3\u0026gt; \u0026amp;lhs, const std::array\u0026lt;int, 3\u0026gt; \u0026amp;rhs) const { auto [_, v1, s1] = lhs; auto [__, v2, s2] = rhs; return 1ll * v1 * s2 \u0026lt; 1ll * v2 * s1; } }; DSU dsu(n); std::priority_queue\u0026lt;std::array\u0026lt;int, 3\u0026gt;, std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt;, comp\u0026gt; heap{}; for (int i = 1; i \u0026lt;= n; ++i) { heap.push({i, a[i], 1}); } modint ans = 0; int size = 0; while (heap.size()) { auto [i, v, cnt] = heap.top(); heap.pop(); int fa = p[i]; if (dsu.leader(i) != i || cnt != dsu.size(i)) continue; int u = dsu.leader(p[i]); ans += 1ll * dsu.size(u) * v; a[u] += v; dsu.merge(u, i); if (u != 0) heap.push({u, a[u], dsu.size(u)}); } ans /= modint(a[0]); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2024-10-21T11:35:33+08:00","image":"https://rafakang.github.io/p/abc376%E9%A2%98%E8%A7%A3/background_hu211459687380468525.png","permalink":"https://rafakang.github.io/p/abc376%E9%A2%98%E8%A7%A3/","title":"ABC376题解"},{"content":"A 题目链接\n串$s$和$t$如果具有一段公共前缀，那么可以用1s的时间复制这段前缀。找到这个最长的公共前缀即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int Main() { std::string s, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n = s.length(), m = t.length(); int ans = n + m; for (int i = 0; i \u0026lt; std::min(n, m); ++i) { if (s[i] != t[i]) break; else ans = std::min(ans, (i + 1) + 1 + (n - i - 1) + (m - i - 1)); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } B 题目链接\n手推一下不难得到，对于$(0\\leq k\u0026lt;n)$，$c[n][k]=2^k$。直接输出答案即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int Main() { int t; read(t); std::vector\u0026lt;int\u0026gt; n(t + 1), k(t + 1); for (int i = 1; i \u0026lt;= t; ++i) { read(n[i]); } for (int i = 1; i \u0026lt;= t; ++i) { read(k[i]); } std::vector\u0026lt;modint\u0026gt; bi(100001); bi[0] = 1; for (int i = 1; i \u0026lt;= 100000; ++i) bi[i] = bi[i - 1] * 2; for (int i = 1; i \u0026lt;= t; ++i) { printf(\u0026#34;%d\\n\u0026#34;, bi[k[i]]); } return 0; } C 题目链接\n最优策略一定是从把价值为$x$的卡拿完之后再去拿$x+1$；重复这个过程直到下一种价值不存在或者已经拿到了$x+k-1$。\n于是排序之后用双指针维护一下即可。\n主要代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int Main() { int n, k; read(n, k); std::vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(a[i]); std::sort(a.begin() + 1, a.end()); int ans = 0; for (int i = 1, j = 1; i \u0026lt;= n; ++i) { if (j \u0026lt; i) j = i; while (j \u0026lt; n \u0026amp;\u0026amp; a[j + 1] - a[j] \u0026lt;= 1 \u0026amp;\u0026amp; a[j + 1] \u0026lt; a[i] + k) ++j; ans = std::max(j - i + 1, ans); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } D 题目链接\n一共有$m$个技能点，每个技能点两种决策，提示我们用DP的方式解决问题。 设$dp[i][j]$表示前$i$个技能点，力量上加了$j$点能够通过的最多关卡。\n显然在第$i$位有两种决策，加到力量上和加到智力上，子问题分别对应$dp[i-1][j-1]$和$dp[i-1][j]$。转移的时候检测一下子问题的状态能够在技能点$i-1$到技能点$i$中间通过多少关卡即可，即中间这些关卡在值域上的一段区间和，用前缀和处理一下就行了。\n主要代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 int Main() { int n, m; read(n, m); std::vector\u0026lt;int\u0026gt; r(n + 1); for (int i = 1; i \u0026lt;= n; ++i) read(r[i]), r[i] += m; std::vector\u0026lt;int\u0026gt; s(1); for (int i = 1; i \u0026lt;= n; ++i) if (r[i] == m) s.push_back(i); s.push_back(n + 1); std::vector dp(m + 2, std::vector\u0026lt;int\u0026gt;(m + 2, -1e9)); dp[0][0] = 0; std::vector\u0026lt;int\u0026gt; b(m + m + 4), sum(m + m + 4); for (int i = 1, p = 1; i \u0026lt;= m + 1; ++i) { for (int j = 0; j \u0026lt;= m + m + 2; ++j) b[j] = 0; while (p \u0026lt; s[i]) { b[r[p]]++; p++; } p++; sum[0] = b[0]; for (int j = 1; j \u0026lt;= m + m + 2; ++j) sum[j] = sum[j - 1] + b[j]; auto query = [\u0026amp;](int l, int r) { if (l == 0) return sum[r]; return sum[r] - sum[l - 1]; }; for (int j = 0; j \u0026lt;= i; ++j) { if (i - 1 \u0026gt;= j) dp[i][j] = std::max(dp[i][j], dp[i - 1][j] + query(-(i - 1 - j) + m, j + m)); if (j \u0026gt;= 1) dp[i][j] = std::max(dp[i][j], dp[i - 1][j - 1] + query(j - i + m, j - 1 + m)); // printf(\u0026#34;dp[%d][%d] = %d\\n\u0026#34;, i, j, dp[i][j]); } } int ans = 0; for (int i = 0; i \u0026lt;= m + 1; ++i) ans = std::max(ans, dp[m + 1][i]); std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; std::endl; return 0; } E 题目链接\n这种计数问题首先考虑计数对象的特征——即什么样的牌能让玩家1永远胜过玩家2。\n1牌很特殊，首先从1牌开始考虑。\n假设玩家2抽到了$k$张1牌，那么玩家1至少要有$k$张1牌，且玩家2的每一张1牌，玩家1都有一张比它更大的。\n如果把这$2k$个牌按大小排序，填上1或者2，发现它就是一个合法的括号序列。\n玩家1还剩下$m-k-k$张1牌。\n那么对于除了1牌的其它牌，玩家2不能被玩家1匹配的牌的数量之和应该恰好等于$m-k-k$。\n$$f[i][j]=f[i-1][j-1]+f[i-1][j+1]$$预处理这个dp。\n接下来考虑除了1牌之外，左括号比右括号一共多$x$张的方案。即一个背包DP，把$f[m][i]$当做物品做背包，体积为$i$。\n$$dp[i][j]=\\sum_{x=0}^{j} dp[i-1][j-x]*f[m][x]$$枚举1牌的方案，玩家1比玩家2多$x$张牌，其实等价于把括号倒过来看，还是左括号比右括号多$x$张牌。\n最终$ans=\\sum_{x=0}^{m}f[m][x]*dp[n][x]$。\n实际上这个题目$n,m$可以做到$10^5$级别。\n首先是括号序列的dp。 前$m$个括号，有左括号比右括号多$i$个，等价于一个格路计数问题：\n左括号看做$(1,0)$,右括号看做$(0,1)$，走的时候不能碰到$y=x+1$这根直线，走到$(\\frac{m+i}{2},\\frac{m-i}{2})$这个坐标。可以用组合数直接得到答案，记为$a[i]$。\n第二个背包DP，用OGF的思想其实是$(\\sum_{i=0}^m a[i]x^i)^n$。多项式快速幂取前$m+1$项即可。\n主要代码（注释里是原数据规模）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 int Main() { int n, m; read(n, m); Combinatorics\u0026lt;modint\u0026gt; combinatorics(m + 1); auto reflection = [\u0026amp;](int x, int y) -\u0026gt; std::pair\u0026lt;int, int\u0026gt; { return {y - 1, x + 1}; }; std::vector\u0026lt;modint\u0026gt; a(m + 1); for (int i = m \u0026amp; 1; i \u0026lt;= m; i += 2) { int x = (m + i) / 2, y = (m - i) / 2; a[i] = combinatorics(x + y, x); std::tie(x, y) = reflection(x, y); if (x \u0026gt;= 0) a[i] -= combinatorics(x + y, x); // printf(\u0026#34;%d%c\u0026#34;, a[i], \u0026#34; \\n\u0026#34;[i == m]); } Poly f(a); Poly g = f.pow(n - 1, m + 1); modint ans = 0; for (int k = 0; k + k \u0026lt;= m; ++k) ans += g[m - k - k] * f[m - k - k]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; /*{ std::vector\u0026lt;modint\u0026gt; catalan(m + 1); catalan[0] = 1; for (int i = 1; i \u0026lt;= m; ++i) catalan[i] = catalan[i - 1] * (i * 4 - 2) * combinatorics.inv[i + 1]; std::vector s(m + 1, std::vector\u0026lt;modint\u0026gt;(m + 1)); std::vector\u0026lt;modint\u0026gt; f(m + 1); s[0][0] = 1; for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 0; j \u0026lt;= i; ++j) { if (j \u0026gt; 0) s[i][j] = s[i - 1][j - 1]; if (j + 1 \u0026lt;= i - 1) s[i][j] += s[i - 1][j + 1]; } } for (int i = 0; i \u0026lt;= m; ++i) f[i] = s[m][i]; std::vector dp(n + 1, std::vector\u0026lt;modint\u0026gt;(m + 1)); dp[1][0] = 1; for (int i = 2; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { for (int d = 0; d \u0026lt;= j; ++d) dp[i][j] += dp[i - 1][j - d] * f[d]; } } modint ans = 0; for (int k = 0; k + k \u0026lt;= m; ++k) ans += s[m][m - k - k] * dp[n][m - k - k]; printf(\u0026#34;%d\\n\u0026#34;, ans); }*/ return 0; } F 题目链接\n首先最终答案每个点代表的数只有0或者1。 证明：\n假设有一个数是2，说明被加了至少两次。把其中1次换成减法，可以得到更小的。\n于是最终一个点被操作了奇数次，则它的数是1；被操作偶数次，它的数是0. 这样就变成了一个奇偶性的判定。\n假设有一个随便的方案。某一个询问中两个点$x,y$，其数字分别是1和1，那么不妨把这个询问的操作换成相反的，得到0,0。\n而数字是(1,0)、(0,1)，再怎么换最终答案还是一样。\n然而假设有两个询问，在某一个点上重叠，状态分别是1,0,1。两询问的操作分别取反，得到0,0,0。\n这似乎跟图会有点关系。\n考虑用一个询问代表一条边，建出图。边的颜色要么是0要么是1。\n如果两个点$u,v$的数都是1，且$u,v$有一条路径相连，那么取反路径上每条边的颜色，只影响$u,v$两个点的值。\n这是一个经典问题，每两个值为1的点配对，路径染色，可以消掉一对1。 最终一个连通块里只有最多1个1。\n由于只需要$u,v$之间有路径，那么建出生成树即可。\n边的0,1染色就可以在树上用异或差分来实现。\n一开始给边随便定方向即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 struct DSU { public: DSU() : n(0) {} explicit DSU(int _n) : n(_n), parent_or_size(_n + 1, -1) {} int merge(int a, int b) { int x = leader(a), y = leader(b); if (x == y) return x; if (-parent_or_size[x] \u0026lt; -parent_or_size[y]) std::swap(x, y); parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x; return x; } bool same(int a, int b) { return leader(a) == leader(b); } int leader(int a) { if (parent_or_size[a] \u0026lt; 0) return a; return parent_or_size[a] = leader(parent_or_size[a]); } int size(int a) { return -parent_or_size[leader(a)]; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; groups() { std::vector\u0026lt;int\u0026gt; leader_buf(n + 1), group_size(n + 1); for (int i = 1; i \u0026lt;= n; i++) { leader_buf[i] = leader(i); group_size[leader_buf[i]]++; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; result(n); for (int i = 1; i \u0026lt;= n; i++) { result[i].reserve(group_size[i]); } for (int i = 1; i \u0026lt;= n; i++) { result[leader_buf[i]].push_back(i); } result.erase( std::remove_if(result.begin(), result.end(), [\u0026amp;](const std::vector\u0026lt;int\u0026gt; \u0026amp;v) { return v.empty(); }), result.end()); return result; } private: int n; // root node: -1 * component size // otherwise: parent std::vector\u0026lt;int\u0026gt; parent_or_size; }; int Main() { int n, q; read(n, q); DSU dsu(n); std::vector adj(n + 1, std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt;{}); std::vector\u0026lt;int\u0026gt; d(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 2\u0026gt;\u0026gt; edge(q + 1); std::vector sub(n + 1, std::vector\u0026lt;int\u0026gt;{}); for (int i = 1; i \u0026lt;= q; ++i) { int u, v; read(u, v); if (!dsu.same(u, v)) { dsu.merge(u, v); adj[u].push_back({v, i}); adj[v].push_back({u, i}); } d[u] ^= 1; edge[i] = {u, v}; } for (int i = 1; i \u0026lt;= n; ++i) { if (d[i] == 1) sub[dsu.leader(i)].push_back(i); } std::vector status(q + 1, 0); std::vector tag(n + 1, 0); auto dfs = [\u0026amp;](auto \u0026amp;\u0026amp;self, int u, int fa) -\u0026gt; void { if (fa != 0) adj[u].erase(std::find_if(adj[u].begin(), adj[u].end(), [\u0026amp;](const std::array\u0026lt;int, 2\u0026gt; \u0026amp;cur) { return cur[0] == fa; })); for (auto [v, i] : adj[u]) { self(self, v, u); status[i] = tag[v]; tag[u] ^= tag[v]; } }; for (int i = 1; i \u0026lt;= n; ++i) { if (dsu.leader(i) != i) continue; auto \u0026amp;s = sub[i]; for (int j = 1; j \u0026lt; s.size(); j += 2) { int u = s[j - 1], v = s[j]; tag[u] ^= 1, tag[v] ^= 1; // printf(\u0026#34;%d %d\\n\u0026#34;, u, v); } dfs(dfs, i, 0); } for (int i = 1; i \u0026lt;= n; ++i) d[i] = 0; for (int i = 1; i \u0026lt;= q; ++i) { if (status[i]) std::swap(edge[i][0], edge[i][1]); auto [u, v] = edge[i]; printf(\u0026#34;%c%c\\n\u0026#34;, (status[i]) ? \u0026#39;y\u0026#39; : \u0026#39;x\u0026#39;, (d[u]) ? \u0026#39;-\u0026#39; : \u0026#39;+\u0026#39;); d[u] ^= 1; } return 0; } ","date":"2024-10-15T16:59:31+08:00","image":"https://rafakang.github.io/p/codeforces-educational-round-170-a~f%E9%A2%98%E8%A7%A3/background_hu267459029147378459.png","permalink":"https://rafakang.github.io/p/codeforces-educational-round-170-a~f%E9%A2%98%E8%A7%A3/","title":"Codeforces Educational Round 170 A~F题解"}]